// const block1 = a => {
//     const block2 = x => {
//         const block3 = y => {
//             return x(y);
//         }
//         return block3(a);
//     };
//     return block2(a);
// }
// const twice = f => f(f);
// const succ = x => x + 1;
// const succ2 = block1(succ);
// const succSucc = twice(succ);
// // succ(0)(0); yet we can prove this is wrong
// succ(succ); //an interesting thing to not be able to prove! 
// succ(succ)(0)(0)(0); //an interesting thing to not be able to prove! 


// const toolId = 0;
// const toolZero = 1;
// const toolTwice = 2;
// const multitool = which => {
//     const id = x => x;
//     const zero = 0;
//     const twice = f => x => f(f(x));
//     return which <= 0 ? id : which - 1 <= 0 ? zero : twice; 
// }
// const useId = multitool(toolId)(0);
// const useZero = 0 + multitool(toolZero);
// const useTwice = (multitool(toolTwice)(x => x - 1))(2);

const pair = s => t => p => p(s)(t);
const fst = s => t => s;
const snd = s => t => t;
const quotInner = n => d => q => { 
    return n + 1 <= 0 
        ? pair(q - 1)(n + d) 
        : quotInner(n - d)(d)(q + 1);
}
const quot = n => d => quotInner(n)(d)(0);
const result = quot(x => x)(12);
const quotient = quot(quot);//result(fst);
const r = x => x;
const remainder = 3;//result(snd);



Solution
	pair : (Num -> (Comp(Ok) -> Num))
	fst : (Num -> (Comp(Ok) -> Num))
	snd : (Comp(Ok) -> Num)
	quotInner : (((Num -> Num) -> (Num -> Num)) -> (Num -> (Num -> Comp(Ok))))
	quot : (((Num -> Num) -> (Num -> Num)) -> (Num -> Comp(Ok)))
	result : Comp(Ok)
	quotient : Num
	r : (Num -> Num)
	remainder : Unknown
Solution
	pair : (Ok -> (Comp(Ok) -> Num))
	fst : (Comp(Ok) -> Num)
	snd : (Num -> (Num -> Ok))
	quotInner : ((Num -> Ok) -> (Ok -> (Num -> Comp(Ok))))
	quot : ((Num -> Ok) -> (Ok -> Comp(Ok)))
	result : Comp(Ok)
	quotient : Comp(Ok)
	r : (Num -> Num)
	remainder : Unknown
Solution
	pair : (Ok -> (Comp(Ok) -> Num))
	fst : (Comp(Ok) -> Num)
	snd : (Num -> (Num -> Ok))
	quotInner : ((Num -> Ok) -> (Ok -> (Num -> Comp(Ok))))
	quot : ((Num -> Ok) -> (Ok -> Comp(Ok)))
	result : Comp(Ok)
	quotient : Comp(Ok)
	r : (Num -> Num)
	remainder : Comp(Ok)
Ill-typed and fails at: result,quotient,remainder
