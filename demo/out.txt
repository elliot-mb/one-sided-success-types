[
  Node {
    type: 'VariableDeclaration',
    start: 0,
    end: 20,
    declarations: [ [Node] ],
    kind: 'const'
  },
  Node {
    type: 'ExpressionStatement',
    start: 21,
    end: 27,
    expression: Node {
      type: 'CallExpression',
      start: 21,
      end: 26,
      callee: [Node],
      arguments: [Array],
      optional: false
    }
  }
]
cTAbsInf
	cTVar
		[(XF == YE) v (XF == Ok) v (YE == !(Ok))]
	[([(XF == YE) v (XF == Ok) v (YE == !(Ok))] ∧ XD == YE -> XF) v (XD == Ok)]
[([([(XF == YE) v (XF == Ok) v (YE == !(Ok))] ∧ XD == YE -> XF) v (XD == Ok)] ∧ XD == TB -> TC)]
cTApp
	cTVar
		[(XK == TB -> TC) v (XK == Ok)]
	cTNum
		[(XL == Num) v (XL == Ok)]
	[([(XK == TB -> TC) v (XK == Ok)] ∧ [(XL == Num) v (XL == Ok)] ∧ XK == XL -> XJ) v (XJ == Ok) v ([(XK == Num ∧ (!(Ok)) -> XJ == ZM -> WN) v (XK == ZM -> WN ∧ (!(Ok)) -> XJ == Num) v (XK == !((!(Ok)) -> XJ)) v (!(XK) == (!(Ok)) -> XJ)] ∧ [(XK == TB -> TC) v (XK == Ok)]) v (XL == !(Ok) ∧ [(XL == Num) v (XL == Ok)])]
[([([(XK == TB -> TC) v (XK == Ok)] ∧ [(XL == Num) v (XL == Ok)] ∧ XK == XL -> XJ) v (XJ == Ok) v ([(XK == Num ∧ (!(Ok)) -> XJ == ZM -> WN) v (XK == ZM -> WN ∧ (!(Ok)) -> XJ == Num) v (XK == !((!(Ok)) -> XJ)) v (!(XK) == (!(Ok)) -> XJ)] ∧ [(XK == TB -> TC) v (XK == Ok)]) v ([(XL == Num) v (XL == Ok)] ∧ XL == !(Ok))] ∧ XJ == TI)]
[([([(XK == TB -> TC) v (XK == Ok)] ∧ [(XL == Num) v (XL == Ok)] ∧ XK == XL -> XJ) v (XJ == Ok) v ([(XK == Num ∧ (!(Ok)) -> XJ == ZM -> WN) v (XK == ZM -> WN ∧ (!(Ok)) -> XJ == Num) v (XK == !((!(Ok)) -> XJ)) v (!(XK) == (!(Ok)) -> XJ)] ∧ [(XK == TB -> TC) v (XK == Ok)]) v ([(XL == Num) v (XL == Ok)] ∧ XL == !(Ok))] ∧ XJ == TI ∧ [([(XF == YE) v (XF == Ok) v (YE == !(Ok))] ∧ XD == YE -> XF) v (XD == Ok)] ∧ XD == TB -> TC)]
const id = (x => x);
id(0);
	id : Untypable
	eval#0 : Untypable
Inconclusive
