const failure = (x => x) - (y => y) - (z => z)
                const eight = 8;
                const nine  = 9;
                const ten   = 10; //obviously these wouldnt actually go wrong
                
Solution
	failure : Comp(Ok)
	eight : Num
	nine : Num
	ten : Num
Ill-typed and fails at: failure

                const myWrong = 0(0);
                const putAWrongIn = x => {
                    const y = z => z;
                    y(x);
                    return 0;
                }
                const aRightIn = putAWrongIn(0);
                const aWrongIn = putAWrongIn(myWrong);
                
Solution
	myWrong : Comp(Ok)
	putAWrongIn : (Num -> Num)
	aRightIn : Num
	aWrongIn : Num
Ill-typed and fails at: myWrong

                const id = x => x;
                const mightFail = x => {
                    return x <= 0 ? 1 : 2(3);
                }
                const guardFail = x => {
                    return (y => y) + x ? 1 : 2;
                }
                const willFail = x => {
                    return x <= 0 ? (0 <= 0 ? 0(0) : 0(0)) : id + id; 
                }
                const mgw = mightFail(guardFail(willFail));
                const gmw = guardFail(mightFail(willFail));
                const wgm = willFail(guardFail(mightFail));
                const mNum = mightFail(0-1); //
                const gNum = guardFail(0); //interesting it doesnt fail here 
                const wNum = willFail(0);  //nor here 
                
Solution
	id : (Num -> Num)
	mightFail : ((Comp(Num) -> Num) -> Comp(Ok))
	guardFail : (Num -> Num)
	willFail : (Comp(Num) -> Num)
	mgw : Ok
	gmw : Comp(Ok)
	wgm : Ok
	mNum : Ok
	gNum : Ok
	wNum : Ok
Ill-typed and fails at: gmw

                const superIffy = cond => {
                    const if1 = x => cond <= 0 ? x : x + 1;
                    const if2 = x => if1(x) <= 0 ? x : x - 1;
                    const if3 = x => if2(x) <= 0 ? x - 1 : x;
                    return if3(if2(if1(cond))) <= 0 ? if1(if2(if3(cond))) : if3(if1(if2(cond)));
                }
                superIffy(0);
                
	superIffy : Untypable
	eval#0 : Untypable
Inconclusive

            const pair = s => t => p => p(s)(t);
            const fst = s => t => s;
            const snd = s => t => t;
            const quotInner = n => d => q => { 
                const lastQ = q - 1;
                const nextQ = q + 1;
                const lastR = n + d;
                const nextR = n - d;
                return n + 1 <= 0 ? pair(lastQ)(lastR) : quotInner(nextR)(d)(nextQ);
            }
            const quot = n => d => quotInner(n)(d)(0);
            const result = quot(x => x)(12);
        
Solution
	pair : (Comp(Ok) -> Num)
	fst : (Comp(Ok) -> Num)
	snd : (Comp(Ok) -> Num)
	quotInner : ((Num -> Num) -> (Ok -> (Ok -> Comp(Ok))))
	quot : ((Num -> Num) -> (Num -> Comp(Ok)))
	result : Comp(Ok)
Ill-typed and fails at: result

            const k = 0;
            const w = (x => x)((y => y) + (z => z));
            const z = 0(0);
        
Solution
	k : Num
	w : Comp(Ok)
	z : Ok
Ill-typed and fails at: w

            0;
            0(0);
            0;
            0(0);
        
Solution
	eval#0 : Num
	eval#1 : Comp(Ok)
	eval#2 : Num
	eval#3 : Ok
Solution
	eval#0 : Ok
	eval#1 : Comp(Ok)
	eval#2 : Num
	eval#3 : Comp(Ok)
Ill-typed and fails at: eval#1,eval#3

            const middleFail = x => {
                const x2 = x + x;
                ((num => num <= 0 ? z => z : y => y)(0)) + 0;
                return 6;
            }
            middleFail(0);
        
Solution
	middleFail : (Num -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const right1 = 0;
            const right2 = 0;
            const wrong1 = (x => x) - (x => x);
            const wrong2 = (x => x) - (x => x);
        
Solution
	right1 : Num
	right2 : Num
	wrong1 : Comp(Ok)
	wrong2 : Num
Solution
	right1 : Num
	right2 : Num
	wrong1 : Comp(Ok)
	wrong2 : Comp(Ok)
Ill-typed and fails at: wrong1,wrong2
const failure = (x => x) - (y => y) - (z => z)
                const eight = 8;
                const nine  = 9;
                const ten   = 10; //obviously these wouldnt actually go wrong
                
Solution
	failure : Comp(Ok)
	eight : Num
	nine : Num
	ten : Num
Ill-typed and fails at: failure

                const myWrong = 0(0);
                const putAWrongIn = x => {
                    const y = z => z;
                    y(x);
                    return 0;
                }
                const aRightIn = putAWrongIn(0);
                const aWrongIn = putAWrongIn(myWrong);
                
Solution
	myWrong : Comp(Ok)
	putAWrongIn : (Num -> Num)
	aRightIn : Num
	aWrongIn : Num
Ill-typed and fails at: myWrong

                const id = x => x;
                const mightFail = x => {
                    return x <= 0 ? 1 : 2(3);
                }
                const guardFail = x => {
                    return (y => y) + x ? 1 : 2;
                }
                const willFail = x => {
                    return x <= 0 ? (0 <= 0 ? 0(0) : 0(0)) : id + id; 
                }
                const mgw = mightFail(guardFail(willFail));
                const gmw = guardFail(mightFail(willFail));
                const wgm = willFail(guardFail(mightFail));
                const mNum = mightFail(0-1); //
                const gNum = guardFail(0); //interesting it doesnt fail here 
                const wNum = willFail(0);  //nor here 
                
Solution
	id : (Num -> Num)
	mightFail : ((Comp(Num) -> Num) -> Comp(Ok))
	guardFail : (Num -> Num)
	willFail : (Comp(Num) -> Num)
	mgw : Ok
	gmw : Comp(Ok)
	wgm : Ok
	mNum : Ok
	gNum : Ok
	wNum : Ok
Ill-typed and fails at: gmw

                const superIffy = cond => {
                    const if1 = x => cond <= 0 ? x : x + 1;
                    const if2 = x => if1(x) <= 0 ? x : x - 1;
                    const if3 = x => if2(x) <= 0 ? x - 1 : x;
                    return if3(if2(if1(cond))) <= 0 ? if1(if2(if3(cond))) : if3(if1(if2(cond)));
                }
                superIffy(0);
                
	superIffy : Untypable
	eval#0 : Untypable
Inconclusive

            const fn = x => {
                0(0);
                return 0;
            }
            fn(0);
        
Solution
	fn : (Ok -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const app2 = 0(0); //Disj(T1, Comp(Ok) -> A);
        
Solution
	app2 : Comp(Ok)
Ill-typed and fails at: app2

            const id = x => x;
            const app3 = (id)(id + id); //T2 = Comp(Ok);
        
Solution
	id : (Num -> Num)
	app3 : Comp(Ok)
Ill-typed and fails at: app3

            const pred = x => x - 1;
            const ifZ1 = pred <= 0 ? 1 : 2; //Disj(T1, Num)
        
Solution
	pred : ((Num -> Num) -> (Num -> Num))
	ifZ1 : Comp(Ok)
Ill-typed and fails at: ifZ1

            const succ = x => x + 1;
            succ(succ); //A = A -> B (untypable)
        
	succ : Untypable
	eval#0 : Untypable
Inconclusive

            (x => x + 1)(x => x + 1); // free conclusion type from NumOp2
        
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const ifZ2 = 0 <= 0 ? (x => x + 1)(x => x + 1) : (x => x + 1)(x => x + 1); 
        
Solution
	ifZ2 : Comp(Ok)
Ill-typed and fails at: ifZ2

            const okC1 = (x => x)(0(0)); //variable x goes wrong (Y1 = Comp(Ok))
        
Solution
	okC1 : Comp(Ok)
Ill-typed and fails at: okC1
f => x => f(f(x));
	eval#0 : Untypable
Inconclusive
(f => g => f + g);
	eval#0 : Untypable
Inconclusive
(f => g => f + g)(0);
	eval#0 : Untypable
Inconclusive
(f => g => f + g)(0)(0);
	eval#0 : Untypable
Inconclusive
(f => g => f + g(0))(0)(x => x);
	eval#0 : Untypable
Inconclusive
(x => x)(0) + 0;
	eval#0 : Untypable
Inconclusive
(x => x);
	eval#0 : Untypable
Inconclusive
(x => x)(0);
	eval#0 : Untypable
Inconclusive
(x => x)(x => x);
	eval#0 : Untypable
Inconclusive
0 + 0;
	eval#0 : Untypable
Inconclusive
1 <= 0 ? 0(0) : 0;
	eval#0 : Untypable
Inconclusive
(f => x => f(f(x)))(y => y + 1)((x => 0)(1));
	eval#0 : Untypable
Inconclusive
(f => x => f(f(x)))(y => x => y)(0);
	eval#0 : Untypable
Inconclusive
x => 0(x);
	eval#0 : Untypable
Inconclusive
0(0);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(x => x) + 0;
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(x => x <= 0 ? 0 : 0)(y => y);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(f => g => f + g)(0)(x => x);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
0 - (x => x <= 0 ? 1 : 0);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(x => x) - (y => y);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(f => x => 0 - f(x)(0)) <= 0 ? 0 : 0;
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(y => x => y(1) + y(x))(x => x + 1)((z => z <= 0 ? (x => x) : (y => y))(0));
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(x => x(0))(0);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
thing => thing
	eval#0 : Untypable
Inconclusive
(cannotBeNum => cannotBeNum(0))(0)
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const x = 0;
        
	x : Untypable
Inconclusive

            const x = y => y;
            const z = w => {
                return x(w);
            }
        
	x : Untypable
	z : Untypable
Inconclusive

            const x = 0;
        
	x : Untypable
Inconclusive

            x => x
        
	eval#0 : Untypable
Inconclusive

            const x = y => y;
        
	x : Untypable
Inconclusive

            const mul = x => y => {
                return x <= 0 ? y : y + mul(x - 1)(y);
            }
        
	mul : Untypable
Inconclusive

            const mul = x => y => {
                return x <= 0 ? y : y + mul(x - 1)(y);
            }
            const result = mul(2)(3);
        
	mul : Untypable
	result : Untypable
Inconclusive

            const pair = m => n => p => p(m)(n);
            const div = n => d => q => {
                const r = n - d; 
                return r + 1 <= 0 ? pair(q)(n) : div(r)(d)(q + 1);
            }
            const goodResult = div(10)(2)(0);
        
	pair : Untypable
	div : Untypable
	goodResult : Untypable
Inconclusive

            const fst = x => y => x;
            const snd = x => y => y;
            const pair = m => n => p => p(m)(n);
            const listZeros = pair(0)(pair(0)(pair(0)(pair(0)(0))));
            const head = fst;
            listZeros(head);
        
	fst : Untypable
	snd : Untypable
	pair : Untypable
	listZeros : Untypable
	head : Untypable
	eval#0 : Untypable
Inconclusive

            const boomPair = m => n => p => 1(x => x) - 1(0)(0)(m)(n);
            const listZeros = boomPair(0)(boomPair(0)(boomPair(0)(boomPair(0)(0))));
        
	boomPair : Untypable
	listZeros : Untypable
Inconclusive

            const pfst = s => t => s;
            const psnd = s => t => t;
            const qfst = q => r => s => t => q;
            const qsnd = q => r => s => t => r;
            const qtrd = q => r => s => t => s;
            const qfrt = q => r => s => t => t;
            const quad = q => r => s => t => p => p(q)(r)(s)(t);
            const pair = r => s => p => p(r)(s);
            const toTwoPairs = inQuad => {
                const p1 = pair(inQuad(qfst))(inQuad(qsnd));
                const p2 = pair(inQuad(qtrd))(inQuad(qfrt));
                return pair(p1)(p2);
            }
            const myQuad = quad(0)(1)(2)(3);
            const firstPair = toTwoPairs(myQuad)(pfst);
            const sndPair = toTwoPairs(myQuad)(psnd);
        
	pfst : Untypable
	psnd : Untypable
	qfst : Untypable
	qsnd : Untypable
	qtrd : Untypable
	qfrt : Untypable
	quad : Untypable
	pair : Untypable
	toTwoPairs : Untypable
	myQuad : Untypable
	firstPair : Untypable
	sndPair : Untypable
Inconclusive

            const id = x => x;
            const explode = x => id - 1;
            const zero = id(0);
        
	id : Untypable
	explode : Untypable
	zero : Untypable
Inconclusive

            const earlyFail = (x => 0)(0)(0);
            const two = 1 + 1;
            two + 1;
        
Solution
	earlyFail : Comp(Ok)
	two : Num
	eval#0 : Ok
Ill-typed and fails at: earlyFail

            const zeroer = x => y => {
                return 0(x) <= 0 ? 0 : 0;
            }
            zeroer(0)(0);
        
Solution
	zeroer : (Num -> (Ok -> Comp(Ok)))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const mul = 0(0);
        
Solution
	mul : Comp(Ok)
Ill-typed and fails at: mul

            const pair = m => n => p => p(m)(n);
            const div = n => d => q => {
                const r = n - d; 
                return r + 1 <= 0 ? pair(q)(n) : div(r)(d)(q + 1);
            }
            
            const badResult = div(x => x)(10)(0);
        
Solution
	pair : (Comp(Ok) -> Num)
	div : ((Num -> Ok) -> (Ok -> (Num -> Comp(Ok))))
	badResult : Comp(Ok)
Ill-typed and fails at: badResult

            const fst = x => y => x;
            const pair = m => n => p => 10(m)(n); 
            const listZeros = pair(0)(pair(0)(pair(0)(pair(0)(0))));
            listZeros(fst);
        
Solution
	fst : (Num -> (Num -> Ok))
	pair : (Ok -> (Ok -> (Ok -> Comp(Ok))))
	listZeros : (Ok -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const snd = x => y => y;
            const pair = m => n => p => p(m)(n);
            const confusedList = pair(0)(0)(0);
        
	snd : Untypable
	pair : Untypable
	confusedList : Untypable
Inconclusive

            const fst = s => t => s;
            const snd = s => t => t;
            const pair = s => t => p => p(s)(t);
            const p1 = pair(0)(1);
            const p2 = pair(2)(3);
            const zipSumPairs = pair1 => pair2 => {
                const e1 = pair1(fst) + pair2(fst);
                const e2 = pair1(snd) + snd(pair2); 
                return pair(e1)(e2);
            }
            const sumPair = zipSumPairs(p1)(p2);
        
Solution
	fst : (Ok -> Ok)
	snd : (Ok -> (Num -> Num))
	pair : (Comp(Ok) -> Num)
	p1 : Ok
	p2 : Ok
	zipSumPairs : (Ok -> (Ok -> Comp(Ok)))
	sumPair : Comp(Ok)
Ill-typed and fails at: sumPair

            const fst = s => t => s;
            const snd = s => t => t;
            const sndFst = snd(fst);
            const idPlus1 = sndFst + 1;
        
Solution
	fst : (Num -> (Num -> Num))
	snd : (Ok -> (Num -> Num))
	sndFst : (Num -> Num)
	idPlus1 : Comp(Ok)
Ill-typed and fails at: idPlus1

            const boomRecursion = x => {
                return x <= 0 ? 0(boomRecursion(x - 1)) : 0(x);
            }
            boomRecursion(10);
        
Solution
	boomRecursion : (Ok -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const id = x => x;
            const funcGoesWrongWhenRun = y => id + id;
            const three = 2 + 1;
        
	id : Untypable
	funcGoesWrongWhenRun : Untypable
	three : Untypable
Inconclusive

            const tenOrId = lTOrGTZ => {
                return lTOrGTZ <= 0 ? x => x : 10;
            }
            const eleven = tenOrId(1) + 1;
        
	tenOrId : Untypable
	eleven : Untypable
Inconclusive

            const id = x => x;
        
	id : Untypable
Inconclusive
[32m successes (98/103):
 	testVariables: line 105
	testVariables: line 106
	testVariables: line 107
	testVariables: line 108
	testVariables: line 109
	testVariables: line 110
	testVariables: line 116
	testExcludeTopDefns: line 554
	testExcludeTopDefns: line 555
	testWhereFails: line 402
	testWhereFails: line 450
	testEarlyFailAt: line 559
	testEarlyFailAt: line 573
	testEarlyFailAt: line 578
	testEarlyFailAt: line 584
	testEarlyFailAt: line 593
	testWhereFails: line 402
	testWhereFails: line 450
	testBlockIgnoresStillIllTyped: line 539
	testTypabilityByRule: line 467
	testTypabilityByRule: line 470
	testTypabilityByRule: line 474
	testTypabilityByRule: line 484
	testTypabilityByRule: line 493
	testTypabilityByRule: line 497
	testTypabilityByRule: line 500
	testTypeEquality: line 131
	testTypeEquality: line 132
	testTypeEquality: line 133
	testTypeEquality: line 134
	testTypeEquality: line 135
	testTypeEquality: line 137
	testTypeEquality: line 140
	testTypeEquality: line 141
	testTypeEquality: line 142
	testTypeEquality: line 143
	testUntypability: line 147
	testUntypability: line 148
	testUntypability: line 149
	testUntypability: line 150
	testUntypability: line 151
	testUntypability: line 152
	testUntypability: line 153
	testUntypability: line 154
	testUntypability: line 155
	testUntypability: line 156
	testUntypability: line 157
	testUntypability: line 158
	testUntypability: line 159
	testUntypability: line 160
	testTypability: line 164
	testTypability: line 165
	testTypability: line 166
	testTypability: line 167
	testTypability: line 168
	testTypability: line 169
	testTypability: line 170
	testTypability: line 171
	testTypability: line 173
	testFreshTypes: line 185
	testCheckTypeShape: line 189
	testCheckTypeShape: line 190
	testLongIdentifiers: line 194
	testLongIdentifiers: line 195
	testValidityOfNewGrammar: line 199
	testValidityOfNewGrammar: line 200
	testValidityOfNewGrammar: line 204
	testValidityOfNewGrammar: line 209
	testValidityOfNewGrammar: line 215
	testReconstrNewGrammarSucceeds: line 224
	testReconstrNewGrammarSucceeds: line 225
	testReconstrNewGrammarSucceeds: line 229
	testReconstrNewGrammarSucceeds: line 240
	testUntypableNewGrammar: line 249
	testUntypableNewGrammar: line 252
	testUntypableNewGrammar: line 258
	testUntypableNewGrammar: line 261
	testUntypableNewGrammar: line 264
	testUntypableNewGrammar: line 267
	testUntypableNewGrammar: line 272
	testUntypableNewGrammar: line 278
	testUntypableNewGrammar: line 286
	testUntypableNewGrammar: line 295
	testUntypableNewGrammar: line 299
	testUntypableNewGrammar: line 317
	testTypeableNewGrammar: line 334
	testTypeableNewGrammar: line 340
	testTypeableNewGrammar: line 346
	testTypeableNewGrammar: line 350
	testTypeableNewGrammar: line 360
	testTypeableNewGrammar: line 373
	testTypeableNewGrammar: line 387
	testTypeableNewGrammar: line 393
	falsePositivesWeCantShowWrong: line 603
	falsePositivesWeCantShowWrong: line 608
	showSimpleRights: line 618
	testProgramsRun: line 525
	testProgramsRun: line 534 [0m
[31m failures (5/103):
 	testWhereFails: line 412
	testWhereFails: line 427
	testWhereFails: line 412
	testWhereFails: line 427
	testTypeableNewGrammar: line 366 [0m
