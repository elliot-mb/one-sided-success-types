const failure = (x => x) - (y => y) - (z => z)
                const eight = 8;
                const nine  = 9;
                const ten   = 10; //obviously these wouldnt actually go wrong
                
Solution
	failure : Comp(Ok)
	eight : Num
	nine : Num
	ten : Num
Ill-typed and fails at: failure

                const myWrong = 0(0);
                const putAWrongIn = x => {
                    const y = z => z;
                    y(x);
                    return 0;
                }
                const aRightIn = putAWrongIn(0);
                const aWrongIn = putAWrongIn(myWrong);
                
Solution
	myWrong : Comp(Ok)
	putAWrongIn : (Comp(Ok) -> (Num -> Num))
	aRightIn : Ok
	aWrongIn : Ok
Solution
	myWrong : Comp(Ok)
	putAWrongIn : (Ok -> Ok)
	aRightIn : Ok
	aWrongIn : Comp(Ok)
Ill-typed and fails at: myWrong,aWrongIn

                const id = x => x;
                const mightFail = x => {
                    return x <= 0 ? 1 : 2(3);
                }
                const guardFail = x => {
                    return (y => y) + x ? 1 : 2;
                }
                const willFail = x => {
                    return x <= 0 ? (0 <= 0 ? 0(0) : 0(0)) : id + id; 
                }
                const mgw = mightFail(guardFail(willFail));
                const gmw = guardFail(mightFail(willFail));
                const wgm = willFail(guardFail(mightFail));
                const mNum = mightFail(0-1);
                const gNum = guardFail(0); 
                const wNum = willFail(0);  
                
Solution
	id : (Num -> Num)
	mightFail : (Comp(Num) -> Num)
	guardFail : ((Comp(Num) -> (Num -> Num)) -> Comp(Ok))
	willFail : (Comp(Num) -> (Num -> Num))
	mgw : Comp(Ok)
	gmw : Ok
	wgm : Ok
	mNum : Ok
	gNum : Ok
	wNum : Ok
Solution
	id : (Comp(Ok) -> Num)
	mightFail : (Comp(Ok) -> Comp(Ok))
	guardFail : ((Num -> Comp(Ok)) -> Comp(Ok))
	willFail : (Num -> Comp(Ok))
	mgw : Comp(Ok)
	gmw : Ok
	wgm : Ok
	mNum : Ok
	gNum : Ok
	wNum : Comp(Ok)
Solution
	id : (Comp(Ok) -> Num)
	mightFail : ((Num -> Comp(Ok)) -> Comp(Ok))
	guardFail : ((Num -> Comp(Ok)) -> Comp(Ok))
	willFail : (Num -> Comp(Ok))
	mgw : Comp(Ok)
	gmw : Comp(Ok)
	wgm : Ok
	mNum : Ok
	gNum : Ok
	wNum : Comp(Ok)
Solution
	id : (Comp(Ok) -> Num)
	mightFail : (Ok -> Ok)
	guardFail : (Ok -> Comp(Ok))
	willFail : (Num -> Comp(Ok))
	mgw : Comp(Ok)
	gmw : Comp(Ok)
	wgm : Comp(Ok)
	mNum : Ok
	gNum : Ok
	wNum : Comp(Ok)
Solution
	id : (Comp(Ok) -> Num)
	mightFail : (Ok -> Ok)
	guardFail : (Ok -> Comp(Ok))
	willFail : (Num -> Comp(Ok))
	mgw : Comp(Ok)
	gmw : Comp(Ok)
	wgm : Comp(Ok)
	mNum : Ok
	gNum : Comp(Ok)
	wNum : Comp(Ok)
Ill-typed and fails at: mgw,gmw,wgm,gNum,wNum

                const superIffy = cond => {
                    const if1 = x => cond <= 0 ? x : x + 1;
                    const if2 = x => if1(x) <= 0 ? x : x - 1;
                    const if3 = x => if2(x) <= 0 ? x - 1 : x;
                    return if3(if2(if1(cond))) <= 0 ? if1(if2(if3(cond))) : if3(if1(if2(cond)));
                }
                superIffy(0);
                
	superIffy : Untypable
	eval#0 : Untypable
Inconclusive

                const stop = 0;  
                const treeNode = lft => val => rgt => lftValRgt => lftValRgt(lft)(val)(rgt);
                const emptyTree = val => treeNode(stop)(val)(stop);
                const pft120 = treeNode
                    (treeNode
                        (emptyTree(3))
                        (12)
                        (treeNode
                            (emptyTree(2))
                            (4)
                            (emptyTree(2))))
                    (120)
                    (treeNode
                        (emptyTree(5))
                        (10)
                        (emptyTree(2)));
                const lft = t => u => v => t;
                const rgt = t => u => v => v;
                const val = t => u => v => u;
                const factorTwiceLeft = pft120(lft)(lft)(val);
                const factorOffTree = pft120(rgt)(lft)(rgt)(lft)(val);
                const factorOffTreeInline = 
                    (treeNode
                            (emptyTree(3))
                        (12)
                            (treeNode
                                    (emptyTree(2))
                                (4)
                                    (emptyTree(2))))
                    (120)
                        (treeNode
                            (emptyTree(5))
                        (10)
                            (emptyTree(2)))(rgt)(lft)(rgt)(lft)(val);
                
Solution
	stop : Ok
	treeNode : (Ok -> (Num ->
   (Ok ->
      (Num ->
         Comp((Comp(Ok) ->
                 ((Num -> Ok) ->
                    ((Comp(Ok) -> Num) ->
                       (Ok -> (Ok -> (Ok -> Comp(Ok))))))))))))
	emptyTree : (Comp(Ok) -> Num)
	pft120 : Ok
	lft : (Comp(Ok) -> Num)
	rgt : (Num -> Ok)
	val : (Num -> (Ok -> Ok))
	factorTwiceLeft : Ok
	factorOffTree : Ok
	factorOffTreeInline : Comp(Ok)
Ill-typed and fails at: factorOffTreeInline

            const pair = s => t => p => p(s)(t);
            const fst = s => t => s;
            const snd = s => t => t;
            const quotInner = n => d => q => { 
                const lastQ = q - 1;
                const nextQ = q + 1;
                const lastR = n + d;
                const nextR = n - d;
                return n + 1 <= 0 ? pair(lastQ)(lastR) : quotInner(nextR)(d)(nextQ);
            }
            const quot = n => d => quotInner(n)(d)(0);
            const result = quot(x => x)(12);
        
Solution
	pair : (Comp(Ok) -> Num)
	fst : (Num -> (Num -> Ok))
	snd : (Comp(Ok) -> Num)
	quotInner : ((Num -> Ok) -> (Ok -> (Num -> Comp(Ok))))
	quot : ((Num -> Ok) -> (Num -> Comp(Ok)))
	result : Comp(Ok)
Ill-typed and fails at: result

            const k = 0;
            const w = (x => x)((y => y) + (z => z));
            const z = 0(0);
        
Solution
	k : Num
	w : Comp(Ok)
	z : Ok
Solution
	k : Num
	w : Comp(Ok)
	z : Comp(Ok)
Ill-typed and fails at: w,z

            0;
            0(0);
            0;
            0(0);
        
Solution
	eval#0 : Num
	eval#1 : Comp(Ok)
	eval#2 : Num
	eval#3 : Ok
Solution
	eval#0 : Ok
	eval#1 : Comp(Ok)
	eval#2 : Num
	eval#3 : Comp(Ok)
Ill-typed and fails at: eval#1,eval#3

            const middleFail = x => {
                const x2 = x + x;
                ((num => num <= 0 ? z => z : y => y)(0)) + 0;
                return 6;
            }
            middleFail(0);
        
Solution
	middleFail : (Ok -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const right1 = 0;
            const right2 = 0;
            const wrong1 = (x => x) - (x => x);
            const wrong2 = (x => x) - (x => x);
        
Solution
	right1 : Num
	right2 : Num
	wrong1 : Comp(Ok)
	wrong2 : Num
Solution
	right1 : Num
	right2 : Ok
	wrong1 : Comp(Ok)
	wrong2 : Comp(Ok)
Ill-typed and fails at: wrong1,wrong2
const failure = (x => x) - (y => y) - (z => z)
                const eight = 8;
                const nine  = 9;
                const ten   = 10; //obviously these wouldnt actually go wrong
                
Solution
	failure : Comp(Ok)
	eight : Num
	nine : Num
	ten : Num
Ill-typed and fails at: failure

                const myWrong = 0(0);
                const putAWrongIn = x => {
                    const y = z => z;
                    y(x);
                    return 0;
                }
                const aRightIn = putAWrongIn(0);
                const aWrongIn = putAWrongIn(myWrong);
                
Solution
	myWrong : Comp(Ok)
	putAWrongIn : (Comp(Ok) -> (Num -> Num))
	aRightIn : Ok
	aWrongIn : Ok
Solution
	myWrong : Comp(Ok)
	putAWrongIn : (Ok -> Ok)
	aRightIn : Ok
	aWrongIn : Comp(Ok)
Ill-typed and fails at: myWrong,aWrongIn

                const id = x => x;
                const mightFail = x => {
                    return x <= 0 ? 1 : 2(3);
                }
                const guardFail = x => {
                    return (y => y) + x ? 1 : 2;
                }
                const willFail = x => {
                    return x <= 0 ? (0 <= 0 ? 0(0) : 0(0)) : id + id; 
                }
                const mgw = mightFail(guardFail(willFail));
                const gmw = guardFail(mightFail(willFail));
                const wgm = willFail(guardFail(mightFail));
                const mNum = mightFail(0-1);
                const gNum = guardFail(0); 
                const wNum = willFail(0);  
                
Solution
	id : (Num -> Num)
	mightFail : (Comp(Num) -> Num)
	guardFail : ((Comp(Num) -> (Num -> Num)) -> Comp(Ok))
	willFail : (Comp(Num) -> (Num -> Num))
	mgw : Comp(Ok)
	gmw : Ok
	wgm : Ok
	mNum : Ok
	gNum : Ok
	wNum : Ok
Solution
	id : (Comp(Ok) -> Num)
	mightFail : (Comp(Ok) -> Comp(Ok))
	guardFail : ((Num -> Comp(Ok)) -> Comp(Ok))
	willFail : (Num -> Comp(Ok))
	mgw : Comp(Ok)
	gmw : Ok
	wgm : Ok
	mNum : Ok
	gNum : Ok
	wNum : Comp(Ok)
Solution
	id : (Comp(Ok) -> Num)
	mightFail : ((Num -> Comp(Ok)) -> Comp(Ok))
	guardFail : ((Num -> Comp(Ok)) -> Comp(Ok))
	willFail : (Num -> Comp(Ok))
	mgw : Comp(Ok)
	gmw : Comp(Ok)
	wgm : Ok
	mNum : Ok
	gNum : Ok
	wNum : Comp(Ok)
Solution
	id : (Comp(Ok) -> Num)
	mightFail : (Ok -> Ok)
	guardFail : (Ok -> Comp(Ok))
	willFail : (Num -> Comp(Ok))
	mgw : Comp(Ok)
	gmw : Comp(Ok)
	wgm : Comp(Ok)
	mNum : Ok
	gNum : Ok
	wNum : Comp(Ok)
Solution
	id : (Comp(Ok) -> Num)
	mightFail : (Ok -> Ok)
	guardFail : (Ok -> Comp(Ok))
	willFail : (Num -> Comp(Ok))
	mgw : Comp(Ok)
	gmw : Comp(Ok)
	wgm : Comp(Ok)
	mNum : Ok
	gNum : Comp(Ok)
	wNum : Comp(Ok)
Ill-typed and fails at: mgw,gmw,wgm,gNum,wNum

                const superIffy = cond => {
                    const if1 = x => cond <= 0 ? x : x + 1;
                    const if2 = x => if1(x) <= 0 ? x : x - 1;
                    const if3 = x => if2(x) <= 0 ? x - 1 : x;
                    return if3(if2(if1(cond))) <= 0 ? if1(if2(if3(cond))) : if3(if1(if2(cond)));
                }
                superIffy(0);
                
	superIffy : Untypable
	eval#0 : Untypable
Inconclusive

                const stop = 0;  
                const treeNode = lft => val => rgt => lftValRgt => lftValRgt(lft)(val)(rgt);
                const emptyTree = val => treeNode(stop)(val)(stop);
                const pft120 = treeNode
                    (treeNode
                        (emptyTree(3))
                        (12)
                        (treeNode
                            (emptyTree(2))
                            (4)
                            (emptyTree(2))))
                    (120)
                    (treeNode
                        (emptyTree(5))
                        (10)
                        (emptyTree(2)));
                const lft = t => u => v => t;
                const rgt = t => u => v => v;
                const val = t => u => v => u;
                const factorTwiceLeft = pft120(lft)(lft)(val);
                const factorOffTree = pft120(rgt)(lft)(rgt)(lft)(val);
                const factorOffTreeInline = 
                    (treeNode
                            (emptyTree(3))
                        (12)
                            (treeNode
                                    (emptyTree(2))
                                (4)
                                    (emptyTree(2))))
                    (120)
                        (treeNode
                            (emptyTree(5))
                        (10)
                            (emptyTree(2)))(rgt)(lft)(rgt)(lft)(val);
                
Solution
	stop : Ok
	treeNode : (Ok -> (Num ->
   (Ok ->
      (Num ->
         Comp((Comp(Ok) ->
                 ((Num -> Ok) ->
                    ((Comp(Ok) -> Num) ->
                       (Ok -> (Ok -> (Ok -> Comp(Ok))))))))))))
	emptyTree : (Comp(Ok) -> Num)
	pft120 : Ok
	lft : (Comp(Ok) -> Num)
	rgt : (Num -> Ok)
	val : (Num -> (Ok -> Ok))
	factorTwiceLeft : Ok
	factorOffTree : Ok
	factorOffTreeInline : Comp(Ok)
Ill-typed and fails at: factorOffTreeInline

            const fn = x => {
                0(0);
                return 0;
            }
            fn(0);
        
Solution
	fn : (Num -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const app2 = 0(0); //Disj(T1, Comp(Ok) -> A);
        
Solution
	app2 : Comp(Ok)
Ill-typed and fails at: app2

            const id = x => x;
            const app3 = (id)(id + id); //T2 = Comp(Ok);
        
Solution
	id : ((Num -> Num) -> (Num -> Num))
	app3 : Comp(Ok)
Ill-typed and fails at: app3

            const pred = x => x - 1;
            const ifZ1 = pred <= 0 ? 1 : 2; //Disj(T1, Num)
        
Solution
	pred : ((Num -> Num) -> (Num -> Num))
	ifZ1 : Comp(Ok)
Ill-typed and fails at: ifZ1

            const succ = x => x + 1;
            succ(succ); //A = A -> B (untypable)
        
	succ : Untypable
	eval#0 : Untypable
Inconclusive

            (x => x + 1)(x => x + 1); // free conclusion type from NumOp2
        
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const ifZ2 = 0 <= 0 ? (x => x + 1)(x => x + 1) : (x => x + 1)(x => x + 1); 
        
Solution
	ifZ2 : Comp(Ok)
Ill-typed and fails at: ifZ2

            const okC1 = (x => x)(0(0)); //variable x goes wrong (Y1 = Comp(Ok))
        
Solution
	okC1 : Comp(Ok)
Ill-typed and fails at: okC1
f => x => f(f(x));
	eval#0 : Untypable
Inconclusive
(f => g => f + g);
	eval#0 : Untypable
Inconclusive
(f => g => f + g)(0);
	eval#0 : Untypable
Inconclusive
(f => g => f + g)(0)(0);
	eval#0 : Untypable
Inconclusive
(f => g => f + g(0))(0)(x => x);
	eval#0 : Untypable
Inconclusive
(x => x)(0) + 0;
	eval#0 : Untypable
Inconclusive
(x => x);
	eval#0 : Untypable
Inconclusive
(x => x)(0);
	eval#0 : Untypable
Inconclusive
(x => x)(x => x);
	eval#0 : Untypable
Inconclusive
0 + 0;
	eval#0 : Untypable
Inconclusive
1 <= 0 ? 0(0) : 0;
	eval#0 : Untypable
Inconclusive
(f => x => f(f(x)))(y => y + 1)((x => 0)(1));
	eval#0 : Untypable
Inconclusive
(f => x => f(f(x)))(y => x => y)(0);
	eval#0 : Untypable
Inconclusive
x => 0(x);
	eval#0 : Untypable
Inconclusive
0(0);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(x => x) + 0;
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(x => x <= 0 ? 0 : 0)(y => y);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(f => g => f + g)(0)(x => x);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
0 - (x => x <= 0 ? 1 : 0);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(x => x) - (y => y);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(f => x => 0 - f(x)(0)) <= 0 ? 0 : 0;
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(y => x => y(1) + y(x))(x => x + 1)((z => z <= 0 ? (x => x) : (y => y))(0));
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
(x => x(0))(0);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
thing => thing
	eval#0 : Untypable
Inconclusive
(cannotBeNum => cannotBeNum(0))(0)
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const x = 0;
        
	x : Untypable
Inconclusive

            const x = y => y;
            const z = w => {
                return x(w);
            }
        
	x : Untypable
	z : Untypable
Inconclusive

            const x = 0;
        
	x : Untypable
Inconclusive

            x => x
        
	eval#0 : Untypable
Inconclusive

            const x = y => y;
        
	x : Untypable
Inconclusive

            const mul = x => y => {
                return x <= 0 ? y : y + mul(x - 1)(y);
            }
        
	mul : Untypable
Inconclusive

            const mul = x => y => {
                return x <= 0 ? y : y + mul(x - 1)(y);
            }
            const result = mul(2)(3);
        
	mul : Untypable
	result : Untypable
Inconclusive

            const pair = m => n => p => p(m)(n);
            const div = n => d => q => {
                const r = n - d; 
                return r + 1 <= 0 ? pair(q)(n) : div(r)(d)(q + 1);
            }
            const goodResult = div(10)(2)(0);
        
	pair : Untypable
	div : Untypable
	goodResult : Untypable
Inconclusive

            const fst = x => y => x;
            const snd = x => y => y;
            const pair = m => n => p => p(m)(n);
            const listZeros = pair(0)(pair(0)(pair(0)(pair(0)(0))));
            const head = fst;
            listZeros(head);
        
	fst : Untypable
	snd : Untypable
	pair : Untypable
	listZeros : Untypable
	head : Untypable
	eval#0 : Untypable
Inconclusive

            const boomPair = m => n => p => 1(x => x) - 1(0)(0)(m)(n);
            const listZeros = boomPair(0)(boomPair(0)(boomPair(0)(boomPair(0)(0))));
        
	boomPair : Untypable
	listZeros : Untypable
Inconclusive

            const pfst = s => t => s;
            const psnd = s => t => t;
            const qfst = q => r => s => t => q;
            const qsnd = q => r => s => t => r;
            const qtrd = q => r => s => t => s;
            const qfrt = q => r => s => t => t;
            const quad = q => r => s => t => p => p(q)(r)(s)(t);
            const pair = r => s => p => p(r)(s);
            const toTwoPairs = inQuad => {
                const p1 = pair(inQuad(qfst))(inQuad(qsnd));
                const p2 = pair(inQuad(qtrd))(inQuad(qfrt));
                return pair(p1)(p2);
            }
            const myQuad = quad(0)(1)(2)(3);
            const firstPair = toTwoPairs(myQuad)(pfst);
            const sndPair = toTwoPairs(myQuad)(psnd);
        
	pfst : Untypable
	psnd : Untypable
	qfst : Untypable
	qsnd : Untypable
	qtrd : Untypable
	qfrt : Untypable
	quad : Untypable
	pair : Untypable
	toTwoPairs : Untypable
	myQuad : Untypable
	firstPair : Untypable
	sndPair : Untypable
Inconclusive

            const id = x => x;
            const explode = x => id - 1;
            const zero = id(0);
        
	id : Untypable
	explode : Untypable
	zero : Untypable
Inconclusive

            const earlyFail = (x => 0)(0)(0);
            const two = 1 + 1;
            two + 1;
        
Solution
	earlyFail : Comp(Ok)
	two : Ok
	eval#0 : Ok
Ill-typed and fails at: earlyFail

            const zeroer = x => y => {
                return 0(x) <= 0 ? 0 : 0;
            }
            zeroer(0)(0);
        
Solution
	zeroer : (Num -> (Ok -> Comp(Ok)))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const mul = 0(0);
        
Solution
	mul : Comp(Ok)
Ill-typed and fails at: mul

            const pair = m => n => p => p(m)(n);
            const div = n => d => q => {
                const r = n - d; 
                return r + 1 <= 0 ? pair(q)(n) : div(r)(d)(q + 1);
            }
            
            const badResult = div(x => x)(10)(0);
        
Solution
	pair : (Comp(Ok) -> (Num -> (Num -> Num)))
	div : ((Comp(Ok) -> Num) -> (Ok -> (Ok -> Comp(Ok))))
	badResult : Comp(Ok)
Ill-typed and fails at: badResult

            const fst = x => y => x;
            const pair = m => n => p => 10(m)(n); 
            const listZeros = pair(0)(pair(0)(pair(0)(pair(0)(0))));
            listZeros(fst);
        
Solution
	fst : (Ok -> Ok)
	pair : (Ok -> (Ok -> ((Ok -> Ok) -> Comp(Ok))))
	listZeros : ((Ok -> Ok) -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const snd = x => y => y;
            const pair = m => n => p => p(m)(n);
            const confusedList = pair(0)(0)(0);
        
Solution
	snd : (Comp(Ok) -> Num)
	pair : (Ok -> (Ok -> (Num -> Comp(Ok))))
	confusedList : Comp(Ok)
Ill-typed and fails at: confusedList

            const fst = s => t => s;
            const snd = s => t => t;
            const pair = s => t => p => p(s)(t);
            const p1 = pair(0)(1);
            const p2 = pair(2)(3);
            const zipSumPairs = pair1 => pair2 => {
                const e1 = pair1(fst) + pair2(fst);
                const e2 = pair1(snd) + snd(pair2); 
                return pair(e1)(e2);
            }
            const sumPair = zipSumPairs(p1)(p2);
        
Solution
	fst : (Ok -> Ok)
	snd : (Ok -> (Num -> Ok))
	pair : (Num -> Ok)
	p1 : Ok
	p2 : Ok
	zipSumPairs : (Ok -> (Ok -> Comp(Ok)))
	sumPair : Comp(Ok)
Ill-typed and fails at: sumPair

            const fst = s => t => s;
            const snd = s => t => t;
            const sndFst = snd(fst);
            const idPlus1 = sndFst + 1;
        
Solution
	fst : (Num -> (Num -> Num))
	snd : (Ok -> (Num -> Num))
	sndFst : (Num -> Num)
	idPlus1 : Comp(Ok)
Ill-typed and fails at: idPlus1

            const boomRecursion = x => {
                return x <= 0 ? 0(boomRecursion(x - 1)) : 0(x);
            }
            boomRecursion(10);
        
Solution
	boomRecursion : (Num -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const fst = x => y => x;
            const pair = m => n => p => 10(m)(n); 
            const listZeros = pair(0)(pair(0)(pair(0)(pair(0)(0))));
            listZeros(fst);
        
Solution
	fst : (Ok -> Ok)
	pair : (Ok -> (Ok -> ((Ok -> Ok) -> Comp(Ok))))
	listZeros : ((Ok -> Ok) -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0

            const id = x => x;
            const funcGoesWrongWhenRun = y => id + id;
            const three = 2 + 1;
        
	id : Untypable
	funcGoesWrongWhenRun : Untypable
	three : Untypable
Inconclusive

            const tenOrId = lTOrGTZ => {
                return lTOrGTZ <= 0 ? x => x : 10;
            }
            const eleven = tenOrId(1) + 1;
        
	tenOrId : Untypable
	eleven : Untypable
Inconclusive

            const id = x => x;
        
	id : Untypable
Inconclusive

            const zero = x => {
                (z => z);
                0(0);
                return 0;
            }
            const g = zero(0) + 0;
        
Solution
	zero : (Ok -> (Num -> Num))
	g : Comp(Ok)
Ill-typed and fails at: g

            const zero = x => {
                (z => z);
                return 0;
            }
            const g = zero(0) + 0;
        
	zero : Untypable
	g : Untypable
Inconclusive

            const what = x => {
                (z => z);
                const succ = y => {
                    (w => w);
                    const h = y + 1;
                    (k => k);
                    return h;
                }
                (l => l);
                return succ(x);
            }
            const g = what(0) + 0;
        
	what : Untypable
	g : Untypable
Inconclusive
[32m successes (109/109):
 	testVariables: line 105
	testVariables: line 106
	testVariables: line 107
	testVariables: line 108
	testVariables: line 109
	testVariables: line 110
	testVariables: line 116
	testExcludeTopDefns: line 601
	testExcludeTopDefns: line 602
	testWhereFails: line 402
	testWhereFails: line 412
	testWhereFails: line 427
	testWhereFails: line 450
	testWhereFails: line 464
	testEarlyFailAt: line 606
	testEarlyFailAt: line 620
	testEarlyFailAt: line 625
	testEarlyFailAt: line 631
	testEarlyFailAt: line 640
	testWhereFails: line 402
	testWhereFails: line 412
	testWhereFails: line 427
	testWhereFails: line 450
	testWhereFails: line 464
	testBlockIgnoresStillIllTyped: line 586
	testTypabilityByRule: line 508
	testTypabilityByRule: line 511
	testTypabilityByRule: line 515
	testTypabilityByRule: line 525
	testTypabilityByRule: line 534
	testTypabilityByRule: line 538
	testTypabilityByRule: line 541
	testTypeEquality: line 131
	testTypeEquality: line 132
	testTypeEquality: line 133
	testTypeEquality: line 134
	testTypeEquality: line 135
	testTypeEquality: line 137
	testTypeEquality: line 140
	testTypeEquality: line 141
	testTypeEquality: line 142
	testTypeEquality: line 143
	testUntypability: line 147
	testUntypability: line 148
	testUntypability: line 149
	testUntypability: line 150
	testUntypability: line 151
	testUntypability: line 152
	testUntypability: line 153
	testUntypability: line 154
	testUntypability: line 155
	testUntypability: line 156
	testUntypability: line 157
	testUntypability: line 158
	testUntypability: line 159
	testUntypability: line 160
	testTypability: line 164
	testTypability: line 165
	testTypability: line 166
	testTypability: line 167
	testTypability: line 168
	testTypability: line 169
	testTypability: line 170
	testTypability: line 171
	testTypability: line 173
	testFreshTypes: line 185
	testCheckTypeShape: line 189
	testCheckTypeShape: line 190
	testLongIdentifiers: line 194
	testLongIdentifiers: line 195
	testValidityOfNewGrammar: line 199
	testValidityOfNewGrammar: line 200
	testValidityOfNewGrammar: line 204
	testValidityOfNewGrammar: line 209
	testValidityOfNewGrammar: line 215
	testReconstrNewGrammarSucceeds: line 224
	testReconstrNewGrammarSucceeds: line 225
	testReconstrNewGrammarSucceeds: line 229
	testReconstrNewGrammarSucceeds: line 240
	testUntypableNewGrammar: line 249
	testUntypableNewGrammar: line 252
	testUntypableNewGrammar: line 258
	testUntypableNewGrammar: line 261
	testUntypableNewGrammar: line 264
	testUntypableNewGrammar: line 267
	testUntypableNewGrammar: line 272
	testUntypableNewGrammar: line 278
	testUntypableNewGrammar: line 286
	testUntypableNewGrammar: line 295
	testUntypableNewGrammar: line 299
	testUntypableNewGrammar: line 317
	testTypeableNewGrammar: line 334
	testTypeableNewGrammar: line 340
	testTypeableNewGrammar: line 346
	testTypeableNewGrammar: line 350
	testTypeableNewGrammar: line 360
	testTypeableNewGrammar: line 366
	testTypeableNewGrammar: line 373
	testTypeableNewGrammar: line 387
	testTypeableNewGrammar: line 393
	testASTRequire: line 554
	falsePositivesWeCantShowWrong: line 682
	falsePositivesWeCantShowWrong: line 687
	showSimpleRights: line 697
	testProgramsRun: line 572
	testProgramsRun: line 581
	testBlockStmtsDontGiveIncorrectType: line 649
	testBlockStmtsDontGiveIncorrectType: line 657
	testBlockStmtsDontGiveIncorrectType: line 664 [0m
[31m failures (0/109):
 	 [0m
