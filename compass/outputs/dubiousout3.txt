const failure = (x => x) - (y => y) - (z => z)
                const eight = 8;
                const nine  = 9;
                const ten   = 10; //obviously these wouldnt actually go wrong
                
Solution
	failure : Comp(Ok)
	eight : Num
	nine : Num
	ten : Num
Ill-typed and fails at: failure
[
  {
    XG: 'Num',
    YI: 'Num',
    ZM: 'Num',
    XQ: 'Num',
    XO: 'To(Num, Num)',
    ZT: 'Num',
    WL: 'Num',
    XH: 'To(Num, Num)',
    TZ: 'Num',
    TX: 'Num',
    YP: 'Num',
    XD: 'To(Num, Num)',
    ZK: 'Num',
    YF: 'Num',
    WS: 'Num',
    WN: 'Num',
    ZR: 'Num',
    TV: 'Num',
    XE: 'To(Num, Num)',
    XJ: 'Num',
    WU: 'Num',
    TB: 'Comp(Ok)',
    XW: 'Num',
    XY: 'Num',
    XAA: 'Num',
    XC: 'Comp(Ok)'
  }
]

                const myWrong = 0(0);
                const putAWrongIn = x => {
                    const y = z => z;
                    y(x);
                    return 0;
                }
                const aRightIn = putAWrongIn(0);
                const aWrongIn = putAWrongIn(myWrong);
                
Solution
	myWrong : Comp(Ok)
	putAWrongIn : (Num -> Num)
	aRightIn : Num
	aWrongIn : Ok
Solution
	myWrong : Comp(Ok)
	putAWrongIn : (Comp(Ok) -> Comp(Ok))
	aRightIn : Ok
	aWrongIn : Comp(Ok)
Ill-typed and fails at: myWrong,aWrongIn
[
  {
    YN: 'Num',
    TAI: 'Ok',
    YO: 'Num',
    XAL: 'Num',
    XAF: 'Num',
    YU: 'Num',
    TAC: 'Num',
    XV: 'Num',
    XL: 'Num',
    XD: 'Num',
    XY: 'To(Num, Num)',
    XE: 'To(Num, Num)',
    XZ: 'Num',
    XAE: 'To(Num, Num)',
    TB: 'Comp(Ok)',
    YK: 'Num',
    WAB: 'To(Num, Num)',
    ZAA: 'To(Num, Comp(Ok))',
    ZF: 'Comp(Ok)',
    WAH: 'Num',
    XX: 'Num',
    XT: 'To(Num, Num)',
    ZAM: 'Comp(Ok)',
    ZAG: 'Comp(Ok)',
    XW: 'Num',
    WAN: 'Ok',
    XM: 'Num',
    YP: 'To(Num, Num)',
    WG: 'Comp(Ok)',
    TI: 'Num',
    TH: 'Num',
    XJ: 'To(Num, Num)',
    XC: 'Comp(Ok)',
    XAD: 'Num',
    XAJ: 'Ok'
  },
  {
    TAI: 'Comp(Ok)',
    YO: 'Num',
    XAL: 'Comp(Ok)',
    TH: 'Comp(Ok)',
    XAF: 'To(Num, Num)',
    TAC: 'Ok',
    XV: 'To(Num, Num)',
    ZF: 'Comp(Ok)',
    WG: 'Comp(Ok)',
    XAD: 'Ok',
    XM: 'Comp(Ok)',
    XY: 'To(Comp(Ok), To(Num, Num))',
    TI: 'Comp(Ok)',
    WAN: 'Num',
    XW: 'To(Num, Num)',
    XE: 'To(Num, Num)',
    XAE: 'To(To(Num, Num), Ok)',
    XJ: 'To(Comp(Ok), Comp(Ok))',
    TB: 'Comp(Ok)',
    YN: 'Num',
    XAJ: 'Comp(Ok)',
    WAB: 'Ok',
    YU: 'Ok',
    XAK: 'To(Comp(Ok), Comp(Ok))',
    ZAM: 'Num',
    XC: 'Comp(Ok)',
    XT: 'To(Ok, To(Num, Num))',
    XX: 'To(Num, Num)',
    XL: 'Comp(Ok)',
    XD: 'Num',
    YP: 'Num',
    ZAG: 'Num',
    XZ: 'Comp(Ok)',
    WAH: 'Num',
    YK: 'Comp(Ok)',
    ZAA: 'Num'
  }
]

                const id = x => x;
                const mightFail = x => {
                    return x <= 0 ? 1 : 2(3);
                }
                const guardFail = x => {
                    return (y => y) + x ? 1 : 2;
                }
                const willFail = x => {
                    return x <= 0 ? (0 <= 0 ? 0(0) : 0(0)) : id + id; 
                }
                const mgw = mightFail(guardFail(willFail));
                const gmw = guardFail(mightFail(willFail));
                const wgm = willFail(guardFail(mightFail));
                const mNum = mightFail(0-1); //
                const gNum = guardFail(0); //interesting it doesnt fail here 
                const wNum = willFail(0);  //nor here 
                
Solution
	id : (Num -> Ok)
	mightFail : ((Num -> Ok) -> Comp(Ok))
	guardFail : (Comp(Ok) -> (Num -> Num))
	willFail : (Num -> Ok)
	mgw : Ok
	gmw : Comp(Ok)
	wgm : Ok
	mNum : Ok
	gNum : Ok
	wNum : Ok
Solution
	id : (Num -> Num)
	mightFail : (Ok -> Ok)
	guardFail : (Ok -> Comp(Ok))
	willFail : (Ok -> Ok)
	mgw : Ok
	gmw : Comp(Ok)
	wgm : Ok
	mNum : Ok
	gNum : Comp(Ok)
	wNum : Ok
Ill-typed and fails at: gmw,gNum
[
  {
    ZDB: 'Num',
    XAF: 'Num',
    XDI: 'To(Num, Num)',
    XAO: 'Ok',
    ZAI: 'Num',
    XAZ: 'Num',
    ZBL: 'Num',
    XCO: 'Num',
    ZCZ: 'Num',
    XAV: 'Num',
    TBP: 'Ok',
    WAJ: 'Num',
    ZBN: 'Num',
    XCY: 'Num',
    XQ: 'Num',
    XBB: 'To(Num, Num)',
    TDL: 'Ok',
    YE: 'Num',
    XDN: 'To(Num, Ok)',
    XCM: 'Num',
    WDA: 'Num',
    XDH: 'Comp(Comp(To(Comp(Ok), Ok)))',
    TCT: 'Ok',
    TBZ: 'Comp(Ok)',
    XCC: 'Comp(Ok)',
    XAW: 'To(Num, Num)',
    YJ: 'To(Num, Ok)',
    WV: 'Ok',
    XK: 'Comp(Ok)',
    XP: 'To(Num, Num)',
    XAA: 'To(Num, Num)',
    XCX: 'Num',
    XBU: 'Num',
    YZ: 'Comp(Ok)',
    XAD: 'To(Comp(Ok), Num)',
    YAE: 'Comp(Ok)',
    XF: 'Ok',
    XBS: 'Num',
    XCD: 'To(To(Num, Ok), Comp(Ok))',
    WDC: 'Num',
    XCE: 'To(Num, Ok)',
    XR: 'To(Num, Num)',
    ZU: 'Num',
    WBO: 'Num',
    TDF: 'Ok',
    WBK: 'Num',
    XAH: 'To(Num, Num)',
    XCW: 'Num',
    XDO: 'Num',
    ZBE: 'Num',
    YAN: 'Num',
    WBF: 'Num',
    TCJ: 'Ok',
    WBM: 'Num',
    XN: 'To(Num, Ok)',
    XCV: 'To(Comp(To(Comp(Ok), Ok)), Comp(To(Comp(Ok), Ok)))',
    ZBJ: 'Num',
    ZCP: 'To(Num, Comp(Ok))',
    ZCF: 'To(Num, Comp(Ok))',
    ZBV: 'To(Num, Comp(Ok))',
    WBD: 'To(Num, Num)',
    ZBC: 'To(Num, Comp(Ok))',
    WAY: 'To(Num, Num)',
    ZAX: 'To(Num, Comp(Ok))',
    WT: 'To(Num, To(Num, Num))',
    ZS: 'To(Num, Comp(Ok))',
    XAG: 'To(Num, Num)',
    XAC: 'To(Num, Num)',
    XAQ: 'Ok',
    XAP: 'Ok',
    ZDD: 'Comp(Ok)',
    WCI: 'Comp(Ok)',
    ZBX: 'Comp(Ok)',
    WDQ: 'Ok',
    XAB: 'To(Num, Num)',
    XM: 'Comp(Ok)',
    WDE: 'Ok',
    XL: 'Comp(Ok)',
    ZDP: 'Comp(Ok)',
    WDK: 'Ok',
    ZDJ: 'Comp(Ok)',
    ZCH: 'Comp(Ok)',
    XO: 'To(Num, Num)',
    ZCR: 'Comp(Ok)',
    XAU: 'Num',
    WCS: 'Ok',
    WBY: 'Ok',
    XBG: 'Num',
    XAS: 'Num',
    TB: 'Num',
    TW: 'Comp(Ok)',
    TAK: 'Num',
    TG: 'To(Num, Ok)',
    TAL: 'Ok',
    TH: 'Comp(Ok)',
    TC: 'Ok',
    TX: 'To(Num, Num)',
    XCU: 'Ok',
    XDG: 'Ok',
    XBQ: 'Ok',
    XCA: 'Comp(Ok)',
    XI: 'To(To(Num, Ok), Comp(Ok))',
    XDM: 'Ok',
    XY: 'To(Comp(Ok), To(Num, Num))',
    XD: 'To(Num, Ok)',
    XCK: 'Ok',
    XAM: 'To(Num, Ok)'
  },
  {
    XAS: 'To(Num, Num)',
    TH: 'Ok',
    ZAI: 'To(Num, Num)',
    ZCP: 'Num',
    ZDP: 'Num',
    WAY: 'Ok',
    XCO: 'Num',
    XY: 'To(Ok, Comp(Ok))',
    ZBX: 'Comp(Ok)',
    ZCZ: 'Ok',
    XCN: 'To(Num, Num)',
    XDG: 'Comp(Ok)',
    WAJ: 'To(Num, Num)',
    ZBN: 'Num',
    ZBV: 'Num',
    WT: 'Ok',
    XQ: 'To(Num, Num)',
    XCL: 'To(Ok, Ok)',
    YE: 'Num',
    XD: 'To(Num, Num)',
    XDN: 'To(Num, Num)',
    XAP: 'Num',
    XCM: 'Ok',
    WDA: 'Ok',
    XAQ: 'To(Ok, Num)',
    XDH: 'To(Ok, Comp(Ok))',
    WBW: 'Ok',
    XBA: 'To(Num, Num)',
    XP: 'Comp(Ok)',
    XBQ: 'Ok',
    XAA: 'Comp(Ok)',
    XAD: 'To(To(Num, Num), To(Num, Num))',
    YAE: 'To(Num, Num)',
    XM: 'To(Ok, Num)',
    XF: 'Num',
    XBS: 'To(Num, Num)',
    XI: 'To(Ok, Ok)',
    XCE: 'Ok',
    XR: 'To(Num, Num)',
    ZU: 'Num',
    TDF: 'Comp(Ok)',
    TB: 'Num',
    XCW: 'Comp(Ok)',
    XAH: 'Comp(Ok)',
    XBT: 'To(Num, Num)',
    XDM: 'Ok',
    XDO: 'To(Num, Num)',
    ZDJ: 'Num',
    XBH: 'Comp(Ok)',
    TX: 'Comp(Ok)',
    XL: 'To(Num, Num)',
    YAN: 'Ok',
    WBF: 'Num',
    ZDD: 'Num',
    ZCF: 'Num',
    XN: 'Num',
    TW: 'Ok',
    ZBJ: 'Ok',
    XAT: 'To(Num, Ok)',
    XBG: 'To(Ok, Num)',
    XAG: 'Comp(To(Num, Num))',
    XCV: 'To(Num, Num)',
    ZDB: 'Ok',
    XAF: 'To(Num, Num)',
    XDI: 'Ok',
    TG: 'Ok',
    XAO: 'Ok',
    XAZ: 'To(Num, Num)',
    XAR: 'Ok',
    WDK: 'Num',
    XCU: 'Ok',
    ZBL: 'Ok',
    WCI: 'Num',
    XBR: 'Num',
    XAV: 'To(Num, Num)',
    TBP: 'Ok',
    WCS: 'Num',
    XAM: 'To(Ok, Ok)',
    XCY: 'Comp(Ok)',
    XBB: 'To(Num, Num)',
    TDL: 'Ok',
    ZS: 'Num',
    XCA: 'Comp(Ok)',
    TCT: 'Ok',
    WCG: 'Num',
    TC: 'Num',
    TBZ: 'Comp(Ok)',
    XAU: 'To(Num, Ok)',
    XCC: 'Ok',
    XAW: 'To(Num, Num)',
    YJ: 'Ok',
    XO: 'Comp(To(Num, Num))',
    WV: 'Num',
    XK: 'Ok',
    ZAX: 'Num',
    TAL: 'Ok',
    ZCH: 'Num',
    ZCR: 'Num',
    XBU: 'Num',
    XCX: 'Comp(Ok)',
    WDE: 'Num',
    YZ: 'Ok',
    XAB: 'Comp(Ok)',
    XCD: 'To(Ok, Ok)',
    WDQ: 'Num',
    WDC: 'Ok',
    WBO: 'Num',
    XAC: 'Comp(Ok)',
    WCQ: 'Num',
    XCK: 'Ok',
    WBK: 'Ok',
    XBI: 'Comp(Ok)',
    ZBC: 'Num',
    TAK: 'Ok',
    WBD: 'Ok',
    ZBE: 'Num',
    XCB: 'To(Ok, Comp(Ok))',
    TCJ: 'Ok',
    WBM: 'Ok',
    WBY: 'Ok',
    lft: '[To(To(Num, Num), Comp(Ok)) -> To(Num, Num), To(To(Num, Num), To(Num, Num)) -> To(Num, Num), To(To(Num, Num), To(Num, Ok)) -> To(Num, Num), To(Comp(Ok), To(Num, Ok)) -> Comp(Ok), To(Num, To(Num, Num)) -> Num, To(Comp(Ok), To(Num, Num)) -> Comp(Ok), To(To(Num, Num), Ok) -> To(Num, Num), To(Comp(Ok), Comp(Ok)) -> Comp(Ok), To(Comp(Ok), Ok) -> Comp(Ok), To(Num, Num) -> Num, To(Num, Ok) -> Num, else -> Ok]',
    rgt: '[To(To(Num, Num), Comp(Ok)) -> Comp(Ok), To(To(Num, Num), To(Num, Num)) -> To(Num, Num), To(Ok, Comp(Ok)) -> Comp(Ok), To(To(Num, Num), To(Num, Ok)) -> To(Num, Ok), To(Comp(Ok), To(Num, Ok)) -> To(Num, Ok), To(Num, To(Num, Num)) -> To(Num, Num), To(Comp(Ok), To(Num, Num)) -> To(Num, Num), To(Comp(Ok), Comp(Ok)) -> Comp(Ok), To(Ok, Num) -> Num, To(Num, Num) -> Num, else -> Ok]'
  }
]

                const superIffy = cond => {
                    const if1 = x => cond <= 0 ? x : x + 1;
                    const if2 = x => if1(x) <= 0 ? x : x - 1;
                    const if3 = x => if2(x) <= 0 ? x - 1 : x;
                    return if3(if2(if1(cond))) <= 0 ? if1(if2(if3(cond))) : if3(if1(if2(cond)));
                }
                superIffy(0);
                
	superIffy : Untypable
	eval#0 : Untypable
Inconclusive
[]

            const pair = s => t => p => p(s)(t);
            const fst = s => t => s;
            const snd = s => t => t;
            const quotInner = n => d => q => { 
                const lastQ = q - 1;
                const nextQ = q + 1;
                const lastR = n + d;
                const nextR = n - d;
                return n + 1 <= 0 ? pair(lastQ)(lastR) : quotInner(nextR)(d)(nextQ);
            }
            const quot = n => d => quotInner(n)(d)(0);
            const result = quot(x => x)(12);
        
Solution
	pair : (Comp(Ok) -> Num)
	fst : (Num -> (Num -> Ok))
	snd : (Comp(Ok) -> Num)
	quotInner : ((Num -> Num) -> (Ok -> (Ok -> Comp(Ok))))
	quot : ((Num -> Num) -> (Num -> Comp(Ok)))
	result : Comp(Ok)
Ill-typed and fails at: result
[
  {
    XNS: 'Comp(Num)',
    XPM: 'Comp(Ok)',
    XPP: 'Comp(Ok)',
    WHI: 'Num',
    XQR: 'To(Ok, Comp(Ok))',
    ZLX: 'Num',
    XAO: 'Comp(Ok)',
    XPY: 'Comp(To(Comp(Ok), Num))',
    XNX: 'Comp(Ok)',
    XH: 'Num',
    XNQ: 'Ok',
    XPX: 'Num',
    WLW: 'Num',
    XY: 'Ok',
    XPG: 'To(Num, Num)',
    XW: 'To(Num, Ok)',
    XQO: 'To(Num, Comp(Ok))',
    XPD: 'Comp(Ok)',
    XRM: 'Num',
    XAM: 'To(Ok, Comp(Ok))',
    ZHH: 'Num',
    XPO: 'To(Comp(Ok), Num)',
    YI: 'To(Ok, Num)',
    ZPB: 'Num',
    XQC: 'Comp(Ok)',
    WNU: 'Num',
    YMA: 'Ok',
    XQQ: 'Comp(Ok)',
    XQS: 'To(Ok, To(Ok, Comp(Ok)))',
    YE: 'Comp(Ok)',
    WLY: 'Num',
    XOW: 'Comp(Ok)',
    ZLV: 'Num',
    XPS: 'Comp(Ok)',
    XQX: 'Ok',
    XPV: 'Comp(Ok)',
    XPE: 'Comp(Ok)',
    XPF: 'To(Num, Num)',
    ZQI: 'Num',
    XRJ: 'Num',
    WPC: 'Num',
    XQU: 'To(Num, Num)',
    XK: 'Num',
    XP: 'To(Num, Num)',
    XLS: 'Ok',
    XLZ: 'Comp(Ok)',
    ZNT: 'Num',
    XRF: 'To(Num, Comp(Ok))',
    ZHF: 'Num',
    XM: 'Ok',
    XF: 'Num',
    XRG: 'To(To(Num, Num), To(Num, Comp(Ok)))',
    YAJ: 'To(Num, Num)',
    YRI: 'Num',
    WHG: 'Num',
    XPN: 'Num',
    XPW: 'Num',
    XJ: 'Num',
    XPZ: 'Comp(Ok)',
    XRH: 'To(Num, Num)',
    YQN: 'To(Num, Num)',
    ZOZ: 'Num',
    ZPK: 'Num',
    XAK: 'To(Ok, To(Ok, Comp(Ok)))',
    YHK: 'Ok',
    YNY: 'Comp(Ok)',
    WPJ: 'Num',
    WPL: 'Num',
    YG: 'Ok',
    ZNV: 'Num',
    XL: 'To(Ok, Num)',
    YAN: 'Ok',
    WQJ: 'Num',
    XQF: 'Num',
    WNW: 'Num',
    WPA: 'Num',
    YAQ: 'Ok',
    YQP: 'Num',
    XHD: 'Comp(Num)',
    XOX: 'To(Num, Num)',
    ZPI: 'Num',
    XRA: 'Ok',
    YX: 'Num',
    XQT: 'To(To(Num, Num), To(Ok, To(Ok, Comp(Ok))))',
    YAL: 'Ok',
    WQZ: 'To(Num, To(Ok, Comp(Ok)))',
    ZQY: 'To(Num, Comp(Ok))',
    WQW: 'To(Num, To(Ok, To(Ok, Comp(Ok))))',
    ZQV: 'To(Num, Comp(Ok))',
    WQH: 'To(Num, Comp(Ok))',
    ZQG: 'To(Num, Comp(Ok))',
    WQE: 'To(Num, Num)',
    ZQD: 'To(Num, Comp(Ok))',
    WQB: 'To(Num, Num)',
    ZQA: 'To(Num, Comp(Ok))',
    WPU: 'To(Num, Comp(Ok))',
    ZPT: 'To(Num, Comp(Ok))',
    WPR: 'To(Num, Num)',
    ZPQ: 'To(Num, Comp(Ok))',
    WO: 'To(Num, Num)',
    ZN: 'To(Num, Comp(Ok))',
    WRL: 'To(Num, To(Num, Comp(Ok)))',
    ZRK: 'To(Num, Comp(Ok))',
    WR: 'Num',
    ZRB: 'Comp(Ok)',
    XHJ: 'Comp(Ok)',
    ZRN: 'Comp(Ok)',
    YAC: 'Comp(Ok)',
    XAP: 'Comp(Ok)',
    WRC: 'Comp(Ok)',
    ZQ: 'Comp(Ok)',
    XHC: 'Ok',
    WRO: 'Comp(Ok)',
    TZ: 'Comp(Ok)',
    TB: 'Comp(Ok)',
    YV: 'Num',
    TS: 'Num',
    TQL: 'To(Num, Comp(Ok))',
    TQK: 'To(Num, Num)',
    XAD: 'Num',
    TAA: 'Num',
    TAG: 'To(Num, Num)',
    TAH: 'To(Ok, To(Ok, Comp(Ok)))',
    TC: 'Num',
    TT: 'To(Num, Ok)',
    TRD: 'Comp(Ok)',
    XQM: 'To(To(Num, Num), To(Num, Comp(Ok)))',
    XAI: 'To(To(Num, Num), To(Ok, To(Ok, Comp(Ok))))',
    XAB: 'To(Comp(Ok), Num)',
    XRE: 'Comp(Ok)',
    XD: 'To(Comp(Ok), Num)',
    XU: 'To(Num, To(Num, Ok))'
  }
]

            const k = 0;
            const w = (x => x)((y => y) + (z => z));
            const z = 0(0);
        
Solution
	k : Num
	w : Comp(Ok)
	z : Ok
Solution
	k : Num
	w : Comp(Ok)
	z : Comp(Ok)
Ill-typed and fails at: w,z
[
  {
    YN: 'Num',
    WQ: 'Num',
    XO: 'Num',
    XX: 'To(To(Comp(Ok), Num), To(Comp(Ok), Num))',
    XH: 'To(Num, Num)',
    YG: 'Ok',
    XL: 'Num',
    XY: 'To(Num, Num)',
    XM: 'To(Num, Num)',
    WS: 'Num',
    XI: 'Comp(Ok)',
    ZR: 'Num',
    TV: 'Ok',
    ZP: 'Comp(Ok)',
    XF: 'Comp(To(Comp(Ok), Num))',
    TD: 'Comp(Ok)',
    XJ: 'To(Comp(Ok), Num)',
    YK: 'Comp(Ok)',
    TB: 'Num',
    WAA: 'Ok',
    WU: 'Comp(Ok)',
    ZT: 'Comp(Ok)',
    ZZ: 'Comp(Ok)',
    XW: 'Ok',
    XC: 'Num',
    XE: 'Comp(Ok)'
  },
  {
    XO: 'Num',
    ZT: 'Num',
    XH: 'Ok',
    XY: 'To(Num, Num)',
    XF: 'To(Num, Ok)',
    XM: 'To(Num, Num)',
    XW: 'Comp(Ok)',
    XI: 'Comp(Ok)',
    TV: 'Comp(Ok)',
    ZR: 'Num',
    ZP: 'Num',
    XE: 'Comp(Ok)',
    XJ: 'To(Num, Num)',
    TB: 'Num',
    YN: 'Num',
    ZZ: 'Comp(Ok)',
    WQ: 'Num',
    XC: 'Num',
    XX: 'Num',
    YG: 'Num',
    XL: 'To(Num, Num)',
    WS: 'Num',
    TD: 'Comp(Ok)',
    WU: 'Num',
    YK: 'Ok',
    WAA: 'Comp(Ok)'
  }
]

            0;
            0(0);
            0;
            0(0);
        
Solution
	eval#0 : Num
	eval#1 : Comp(Ok)
	eval#2 : Num
	eval#3 : Ok
Solution
	eval#0 : Ok
	eval#1 : Comp(Ok)
	eval#2 : Num
	eval#3 : Comp(Ok)
Ill-typed and fails at: eval#1,eval#3
[
  {
    XI: 'Ok',
    XD: 'Num',
    XK: 'To(Num, Num)',
    XE: 'To(Num, Num)',
    XC: 'Comp(Ok)',
    XH: 'Num',
    XB: 'Num',
    ZF: 'Comp(Ok)',
    ZL: 'Comp(Ok)',
    WG: 'Comp(Ok)',
    WM: 'Ok'
  },
  {
    WG: 'Comp(Ok)',
    ZL: 'Comp(Ok)',
    XD: 'Num',
    XB: 'Ok',
    WM: 'Comp(Ok)',
    XI: 'Comp(Ok)',
    XK: 'To(Num, Num)',
    XE: 'To(Num, Num)',
    XC: 'Comp(Ok)',
    XJ: 'Num',
    XH: 'Num',
    ZF: 'Comp(Ok)'
  }
]

            const middleFail = x => {
                const x2 = x + x;
                ((num => num <= 0 ? z => z : y => y)(0)) + 0;
                return 6;
            }
            middleFail(0);
        
Solution
	middleFail : (Ok -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    WBG: 'Num',
    YQ: 'Num',
    WAL: 'Num',
    XAS: 'Comp(Num)',
    XAT: 'To(Comp(Ok), Num)',
    WAC: 'Num',
    XAW: 'To(Comp(Ok), Num)',
    XAO: 'To(Num, Ok)',
    XK: 'To(Num, Num)',
    XP: 'To(Num, Num)',
    ZAI: 'Num',
    XAA: 'To(To(Comp(Ok), To(Num, Num)), To(Comp(Ok), To(Num, Num)))',
    ZAK: 'Num',
    YT: 'Num',
    XAR: 'To(Comp(Ok), Num)',
    YAU: 'Comp(Ok)',
    XF: 'Comp(Ok)',
    YH: 'Comp(Ok)',
    WBI: 'Num',
    XBK: 'To(Ok, Comp(Ok))',
    XR: 'Num',
    XAV: 'Num',
    WAE: 'Num',
    WAJ: 'Num',
    ZV: 'Num',
    YM: 'Ok',
    WBA: 'Num',
    ZAD: 'Num',
    XS: 'To(Num, Num)',
    XBL: 'Ok',
    WW: 'Num',
    XBB: 'To(Num, Num)',
    XX: 'Ok',
    ZAB: 'Num',
    YE: 'Ok',
    XL: 'To(Ok, To(Num, Num))',
    YAQ: 'Comp(Num)',
    XU: 'Num',
    ZAZ: 'Num',
    XAY: 'Num',
    XN: 'To(Num, Num)',
    ZBF: 'Num',
    ZBH: 'Num',
    YAX: 'Comp(Ok)',
    ZY: 'To(Num, Comp(Ok))',
    ZBC: 'To(Num, Comp(Ok))',
    XG: 'Comp(Ok)',
    XJ: 'Comp(Ok)',
    WBN: 'Comp(Ok)',
    XI: 'Comp(Ok)',
    XAF: 'Comp(Ok)',
    XAN: 'Comp(Ok)',
    XAM: 'Comp(Ok)',
    ZBM: 'Comp(Ok)',
    TB: 'Ok',
    TC: 'Comp(Ok)',
    XBJ: 'Comp(Ok)',
    XD: 'To(Ok, Comp(Ok))'
  }
]

            const right1 = 0;
            const right2 = 0;
            const wrong1 = (x => x) - (x => x);
            const wrong2 = (x => x) - (x => x);
        
Solution
	right1 : Num
	right2 : Num
	wrong1 : Comp(Ok)
	wrong2 : Num
Solution
	right1 : Num
	right2 : Num
	wrong1 : Comp(Ok)
	wrong2 : Comp(Ok)
Ill-typed and fails at: wrong1,wrong2
[
  {
    TB: 'Num',
    WAA: 'Num',
    ZZ: 'Num',
    WQ: 'Num',
    YI: 'Num',
    WAC: 'Num',
    YU: 'Num',
    XK: 'To(Comp(Ok), Comp(Ok))',
    XT: 'To(Num, Ok)',
    XH: 'To(Num, Num)',
    XV: 'Ok',
    WO: 'Num',
    ZAB: 'Num',
    TF: 'Comp(Ok)',
    XY: 'Num',
    XM: 'To(Num, Num)',
    YL: 'Ok',
    XW: 'To(Num, Num)',
    ZP: 'Num',
    ZN: 'Num',
    XJ: 'Num',
    TD: 'Num',
    YX: 'Num',
    XG: 'Comp(Ok)',
    XC: 'Num',
    TR: 'Num',
    XS: 'Num',
    XE: 'Num'
  },
  {
    XG: 'Comp(Ok)',
    WAC: 'Num',
    TR: 'Comp(Ok)',
    XK: 'Num',
    XH: 'To(Num, Num)',
    XV: 'To(Num, Num)',
    WO: 'Num',
    XY: 'Num',
    XM: 'To(Num, Num)',
    YL: 'Ok',
    XW: 'To(Comp(Ok), Num)',
    XE: 'Num',
    ZP: 'Num',
    ZN: 'Num',
    XJ: 'Num',
    TB: 'Num',
    ZZ: 'Num',
    XS: 'Comp(Ok)',
    WQ: 'Num',
    YI: 'Num',
    YU: 'Ok',
    XC: 'Num',
    XT: 'To(Ok, Num)',
    ZAB: 'Comp(Ok)',
    TF: 'Comp(Ok)',
    TD: 'Num',
    YX: 'Comp(Ok)',
    WAA: 'Num'
  }
]
const failure = (x => x) - (y => y) - (z => z)
                const eight = 8;
                const nine  = 9;
                const ten   = 10; //obviously these wouldnt actually go wrong
                
Solution
	failure : Comp(Ok)
	eight : Num
	nine : Num
	ten : Num
Ill-typed and fails at: failure
[
  {
    XG: 'Num',
    YI: 'Num',
    ZM: 'Num',
    XQ: 'Num',
    XO: 'To(Num, Num)',
    ZT: 'Num',
    WL: 'Num',
    XH: 'To(Num, Num)',
    TZ: 'Num',
    TX: 'Num',
    YP: 'Num',
    XD: 'To(Num, Num)',
    ZK: 'Num',
    YF: 'Num',
    WS: 'Num',
    WN: 'Num',
    ZR: 'Num',
    TV: 'Num',
    XE: 'To(Num, Num)',
    XJ: 'Num',
    WU: 'Num',
    TB: 'Comp(Ok)',
    XW: 'Num',
    XY: 'Num',
    XAA: 'Num',
    XC: 'Comp(Ok)'
  }
]

                const myWrong = 0(0);
                const putAWrongIn = x => {
                    const y = z => z;
                    y(x);
                    return 0;
                }
                const aRightIn = putAWrongIn(0);
                const aWrongIn = putAWrongIn(myWrong);
                
Solution
	myWrong : Comp(Ok)
	putAWrongIn : (Num -> Num)
	aRightIn : Num
	aWrongIn : Ok
Solution
	myWrong : Comp(Ok)
	putAWrongIn : (Comp(Ok) -> Comp(Ok))
	aRightIn : Ok
	aWrongIn : Comp(Ok)
Ill-typed and fails at: myWrong,aWrongIn
[
  {
    YN: 'Num',
    TAI: 'Ok',
    YO: 'Num',
    XAL: 'Num',
    XAF: 'Num',
    YU: 'Num',
    TAC: 'Num',
    XV: 'Num',
    XL: 'Num',
    XD: 'Num',
    XY: 'To(Num, Num)',
    XE: 'To(Num, Num)',
    XZ: 'Num',
    XAE: 'To(Num, Num)',
    TB: 'Comp(Ok)',
    YK: 'Num',
    WAB: 'To(Num, Num)',
    ZAA: 'To(Num, Comp(Ok))',
    ZF: 'Comp(Ok)',
    WAH: 'Num',
    XX: 'Num',
    XT: 'To(Num, Num)',
    ZAM: 'Comp(Ok)',
    ZAG: 'Comp(Ok)',
    XW: 'Num',
    WAN: 'Ok',
    XM: 'Num',
    YP: 'To(Num, Num)',
    WG: 'Comp(Ok)',
    TI: 'Num',
    TH: 'Num',
    XJ: 'To(Num, Num)',
    XC: 'Comp(Ok)',
    XAD: 'Num',
    XAJ: 'Ok'
  },
  {
    TAI: 'Comp(Ok)',
    YO: 'Num',
    XAL: 'Comp(Ok)',
    TH: 'Comp(Ok)',
    XAF: 'To(Num, Num)',
    TAC: 'Ok',
    XV: 'To(Num, Num)',
    ZF: 'Comp(Ok)',
    WG: 'Comp(Ok)',
    XAD: 'Ok',
    XM: 'Comp(Ok)',
    XY: 'To(Comp(Ok), To(Num, Num))',
    TI: 'Comp(Ok)',
    WAN: 'Num',
    XW: 'To(Num, Num)',
    XE: 'To(Num, Num)',
    XAE: 'To(To(Num, Num), Ok)',
    XJ: 'To(Comp(Ok), Comp(Ok))',
    TB: 'Comp(Ok)',
    YN: 'Num',
    XAJ: 'Comp(Ok)',
    WAB: 'Ok',
    YU: 'Ok',
    XAK: 'To(Comp(Ok), Comp(Ok))',
    ZAM: 'Num',
    XC: 'Comp(Ok)',
    XT: 'To(Ok, To(Num, Num))',
    XX: 'To(Num, Num)',
    XL: 'Comp(Ok)',
    XD: 'Num',
    YP: 'Num',
    ZAG: 'Num',
    XZ: 'Comp(Ok)',
    WAH: 'Num',
    YK: 'Comp(Ok)',
    ZAA: 'Num'
  }
]

                const id = x => x;
                const mightFail = x => {
                    return x <= 0 ? 1 : 2(3);
                }
                const guardFail = x => {
                    return (y => y) + x ? 1 : 2;
                }
                const willFail = x => {
                    return x <= 0 ? (0 <= 0 ? 0(0) : 0(0)) : id + id; 
                }
                const mgw = mightFail(guardFail(willFail));
                const gmw = guardFail(mightFail(willFail));
                const wgm = willFail(guardFail(mightFail));
                const mNum = mightFail(0-1); //
                const gNum = guardFail(0); //interesting it doesnt fail here 
                const wNum = willFail(0);  //nor here 
                
Solution
	id : (Num -> Ok)
	mightFail : ((Num -> Ok) -> Comp(Ok))
	guardFail : (Comp(Ok) -> (Num -> Num))
	willFail : (Num -> Ok)
	mgw : Ok
	gmw : Comp(Ok)
	wgm : Ok
	mNum : Ok
	gNum : Ok
	wNum : Ok
Solution
	id : (Num -> Num)
	mightFail : (Ok -> Ok)
	guardFail : (Ok -> Comp(Ok))
	willFail : (Ok -> Ok)
	mgw : Ok
	gmw : Comp(Ok)
	wgm : Ok
	mNum : Ok
	gNum : Comp(Ok)
	wNum : Ok
Ill-typed and fails at: gmw,gNum
[
  {
    ZDB: 'Num',
    XAF: 'Num',
    XDI: 'To(Num, Num)',
    XAO: 'Ok',
    ZAI: 'Num',
    XAZ: 'Num',
    ZBL: 'Num',
    XCO: 'Num',
    ZCZ: 'Num',
    XAV: 'Num',
    TBP: 'Ok',
    WAJ: 'Num',
    ZBN: 'Num',
    XCY: 'Num',
    XQ: 'Num',
    XBB: 'To(Num, Num)',
    TDL: 'Ok',
    YE: 'Num',
    XDN: 'To(Num, Ok)',
    XCM: 'Num',
    WDA: 'Num',
    XDH: 'Comp(Comp(To(Comp(Ok), Ok)))',
    TCT: 'Ok',
    TBZ: 'Comp(Ok)',
    XCC: 'Comp(Ok)',
    XAW: 'To(Num, Num)',
    YJ: 'To(Num, Ok)',
    WV: 'Ok',
    XK: 'Comp(Ok)',
    XP: 'To(Num, Num)',
    XAA: 'To(Num, Num)',
    XCX: 'Num',
    XBU: 'Num',
    YZ: 'Comp(Ok)',
    XAD: 'To(Comp(Ok), Num)',
    YAE: 'Comp(Ok)',
    XF: 'Ok',
    XBS: 'Num',
    XCD: 'To(To(Num, Ok), Comp(Ok))',
    WDC: 'Num',
    XCE: 'To(Num, Ok)',
    XR: 'To(Num, Num)',
    ZU: 'Num',
    WBO: 'Num',
    TDF: 'Ok',
    WBK: 'Num',
    XAH: 'To(Num, Num)',
    XCW: 'Num',
    XDO: 'Num',
    ZBE: 'Num',
    YAN: 'Num',
    WBF: 'Num',
    TCJ: 'Ok',
    WBM: 'Num',
    XN: 'To(Num, Ok)',
    XCV: 'To(Comp(To(Comp(Ok), Ok)), Comp(To(Comp(Ok), Ok)))',
    ZBJ: 'Num',
    ZCP: 'To(Num, Comp(Ok))',
    ZCF: 'To(Num, Comp(Ok))',
    ZBV: 'To(Num, Comp(Ok))',
    WBD: 'To(Num, Num)',
    ZBC: 'To(Num, Comp(Ok))',
    WAY: 'To(Num, Num)',
    ZAX: 'To(Num, Comp(Ok))',
    WT: 'To(Num, To(Num, Num))',
    ZS: 'To(Num, Comp(Ok))',
    XAG: 'To(Num, Num)',
    XAC: 'To(Num, Num)',
    XAQ: 'Ok',
    XAP: 'Ok',
    ZDD: 'Comp(Ok)',
    WCI: 'Comp(Ok)',
    ZBX: 'Comp(Ok)',
    WDQ: 'Ok',
    XAB: 'To(Num, Num)',
    XM: 'Comp(Ok)',
    WDE: 'Ok',
    XL: 'Comp(Ok)',
    ZDP: 'Comp(Ok)',
    WDK: 'Ok',
    ZDJ: 'Comp(Ok)',
    ZCH: 'Comp(Ok)',
    XO: 'To(Num, Num)',
    ZCR: 'Comp(Ok)',
    XAU: 'Num',
    WCS: 'Ok',
    WBY: 'Ok',
    XBG: 'Num',
    XAS: 'Num',
    TB: 'Num',
    TW: 'Comp(Ok)',
    TAK: 'Num',
    TG: 'To(Num, Ok)',
    TAL: 'Ok',
    TH: 'Comp(Ok)',
    TC: 'Ok',
    TX: 'To(Num, Num)',
    XCU: 'Ok',
    XDG: 'Ok',
    XBQ: 'Ok',
    XCA: 'Comp(Ok)',
    XI: 'To(To(Num, Ok), Comp(Ok))',
    XDM: 'Ok',
    XY: 'To(Comp(Ok), To(Num, Num))',
    XD: 'To(Num, Ok)',
    XCK: 'Ok',
    XAM: 'To(Num, Ok)'
  },
  {
    XAS: 'To(Num, Num)',
    TH: 'Ok',
    ZAI: 'To(Num, Num)',
    ZCP: 'Num',
    ZDP: 'Num',
    WAY: 'Ok',
    XCO: 'Num',
    XY: 'To(Ok, Comp(Ok))',
    ZBX: 'Comp(Ok)',
    ZCZ: 'Ok',
    XCN: 'To(Num, Num)',
    XDG: 'Comp(Ok)',
    WAJ: 'To(Num, Num)',
    ZBN: 'Num',
    ZBV: 'Num',
    WT: 'Ok',
    XQ: 'To(Num, Num)',
    XCL: 'To(Ok, Ok)',
    YE: 'Num',
    XD: 'To(Num, Num)',
    XDN: 'To(Num, Num)',
    XAP: 'Num',
    XCM: 'Ok',
    WDA: 'Ok',
    XAQ: 'To(Ok, Num)',
    XDH: 'To(Ok, Comp(Ok))',
    WBW: 'Ok',
    XBA: 'To(Num, Num)',
    XP: 'Comp(Ok)',
    XBQ: 'Ok',
    XAA: 'Comp(Ok)',
    XAD: 'To(To(Num, Num), To(Num, Num))',
    YAE: 'To(Num, Num)',
    XM: 'To(Ok, Num)',
    XF: 'Num',
    XBS: 'To(Num, Num)',
    XI: 'To(Ok, Ok)',
    XCE: 'Ok',
    XR: 'To(Num, Num)',
    ZU: 'Num',
    TDF: 'Comp(Ok)',
    TB: 'Num',
    XCW: 'Comp(Ok)',
    XAH: 'Comp(Ok)',
    XBT: 'To(Num, Num)',
    XDM: 'Ok',
    XDO: 'To(Num, Num)',
    ZDJ: 'Num',
    XBH: 'Comp(Ok)',
    TX: 'Comp(Ok)',
    XL: 'To(Num, Num)',
    YAN: 'Ok',
    WBF: 'Num',
    ZDD: 'Num',
    ZCF: 'Num',
    XN: 'Num',
    TW: 'Ok',
    ZBJ: 'Ok',
    XAT: 'To(Num, Ok)',
    XBG: 'To(Ok, Num)',
    XAG: 'Comp(To(Num, Num))',
    XCV: 'To(Num, Num)',
    ZDB: 'Ok',
    XAF: 'To(Num, Num)',
    XDI: 'Ok',
    TG: 'Ok',
    XAO: 'Ok',
    XAZ: 'To(Num, Num)',
    XAR: 'Ok',
    WDK: 'Num',
    XCU: 'Ok',
    ZBL: 'Ok',
    WCI: 'Num',
    XBR: 'Num',
    XAV: 'To(Num, Num)',
    TBP: 'Ok',
    WCS: 'Num',
    XAM: 'To(Ok, Ok)',
    XCY: 'Comp(Ok)',
    XBB: 'To(Num, Num)',
    TDL: 'Ok',
    ZS: 'Num',
    XCA: 'Comp(Ok)',
    TCT: 'Ok',
    WCG: 'Num',
    TC: 'Num',
    TBZ: 'Comp(Ok)',
    XAU: 'To(Num, Ok)',
    XCC: 'Ok',
    XAW: 'To(Num, Num)',
    YJ: 'Ok',
    XO: 'Comp(To(Num, Num))',
    WV: 'Num',
    XK: 'Ok',
    ZAX: 'Num',
    TAL: 'Ok',
    ZCH: 'Num',
    ZCR: 'Num',
    XBU: 'Num',
    XCX: 'Comp(Ok)',
    WDE: 'Num',
    YZ: 'Ok',
    XAB: 'Comp(Ok)',
    XCD: 'To(Ok, Ok)',
    WDQ: 'Num',
    WDC: 'Ok',
    WBO: 'Num',
    XAC: 'Comp(Ok)',
    WCQ: 'Num',
    XCK: 'Ok',
    WBK: 'Ok',
    XBI: 'Comp(Ok)',
    ZBC: 'Num',
    TAK: 'Ok',
    WBD: 'Ok',
    ZBE: 'Num',
    XCB: 'To(Ok, Comp(Ok))',
    TCJ: 'Ok',
    WBM: 'Ok',
    WBY: 'Ok',
    lft: '[To(To(Num, Num), Comp(Ok)) -> To(Num, Num), To(To(Num, Num), To(Num, Num)) -> To(Num, Num), To(To(Num, Num), To(Num, Ok)) -> To(Num, Num), To(Comp(Ok), To(Num, Ok)) -> Comp(Ok), To(Num, To(Num, Num)) -> Num, To(Comp(Ok), To(Num, Num)) -> Comp(Ok), To(To(Num, Num), Ok) -> To(Num, Num), To(Comp(Ok), Comp(Ok)) -> Comp(Ok), To(Comp(Ok), Ok) -> Comp(Ok), To(Num, Num) -> Num, To(Num, Ok) -> Num, else -> Ok]',
    rgt: '[To(To(Num, Num), Comp(Ok)) -> Comp(Ok), To(To(Num, Num), To(Num, Num)) -> To(Num, Num), To(Ok, Comp(Ok)) -> Comp(Ok), To(To(Num, Num), To(Num, Ok)) -> To(Num, Ok), To(Comp(Ok), To(Num, Ok)) -> To(Num, Ok), To(Num, To(Num, Num)) -> To(Num, Num), To(Comp(Ok), To(Num, Num)) -> To(Num, Num), To(Comp(Ok), Comp(Ok)) -> Comp(Ok), To(Ok, Num) -> Num, To(Num, Num) -> Num, else -> Ok]'
  }
]

                const superIffy = cond => {
                    const if1 = x => cond <= 0 ? x : x + 1;
                    const if2 = x => if1(x) <= 0 ? x : x - 1;
                    const if3 = x => if2(x) <= 0 ? x - 1 : x;
                    return if3(if2(if1(cond))) <= 0 ? if1(if2(if3(cond))) : if3(if1(if2(cond)));
                }
                superIffy(0);
                
	superIffy : Untypable
	eval#0 : Untypable
Inconclusive
[]

            const fn = x => {
                0(0);
                return 0;
            }
            fn(0);
        
Solution
	fn : (Ok -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    XO: 'Ok',
    YE: 'Ok',
    XN: 'To(Ok, Comp(Ok))',
    XF: 'Comp(Ok)',
    XJ: 'To(Num, Num)',
    XI: 'Num',
    XG: 'Comp(Ok)',
    WL: 'Comp(Ok)',
    XH: 'Comp(Ok)',
    ZK: 'Comp(Ok)',
    WQ: 'Comp(Ok)',
    ZP: 'Comp(Ok)',
    TB: 'Ok',
    TC: 'Comp(Ok)',
    XM: 'Comp(Ok)',
    XD: 'To(Ok, Comp(Ok))'
  }
]

            const app2 = 0(0); //Disj(T1, Comp(Ok) -> A);
        
Solution
	app2 : Comp(Ok)
Ill-typed and fails at: app2
[
  {
    XD: 'Num',
    XE: 'To(Num, Num)',
    ZF: 'Comp(Ok)',
    WG: 'Comp(Ok)',
    TB: 'Comp(Ok)',
    XC: 'Comp(Ok)'
  }
]

            const id = x => x;
            const app3 = (id)(id + id); //T2 = Comp(Ok);
        
Solution
	id : ((Num -> Num) -> (Num -> Num))
	app3 : Comp(Ok)
Ill-typed and fails at: app3
[
  {
    YE: 'To(Num, Num)',
    XL: 'To(Num, Num)',
    WN: 'To(Num, Num)',
    XF: 'To(Num, Num)',
    ZM: 'To(Num, Num)',
    ZO: 'Num',
    XI: 'Comp(To(Num, Num))',
    XK: 'To(To(Num, Num), To(Num, Num))',
    XJ: 'Comp(Ok)',
    WP: 'Num',
    WR: 'Comp(Ok)',
    ZQ: 'Comp(Ok)',
    TB: 'To(Num, Num)',
    TC: 'To(Num, Num)',
    XH: 'Comp(Ok)',
    XD: 'To(To(Num, Num), To(Num, Num))',
    TG: 'Comp(Ok)'
  }
]

            const pred = x => x - 1;
            const ifZ1 = pred <= 0 ? 1 : 2; //Disj(T1, Num)
        
Solution
	pred : ((Num -> Num) -> (Num -> Num))
	ifZ1 : Comp(Ok)
Ill-typed and fails at: ifZ1
[
  {
    YE: 'To(Num, Num)',
    ZK: 'Num',
    XF: 'To(Num, Num)',
    WS: 'To(Num, Num)',
    XO: 'To(To(Num, Num), To(Num, Num))',
    ZI: 'Num',
    WJ: 'Num',
    ZR: 'To(Num, Num)',
    WL: 'Num',
    XG: 'To(Num, Num)',
    TB: 'To(Num, Num)',
    TC: 'To(Num, Num)',
    TM: 'Comp(Ok)',
    XN: 'Comp(Ok)',
    XD: 'To(To(Num, Num), To(Num, Num))'
  }
]

            const succ = x => x + 1;
            succ(succ); //A = A -> B (untypable)
        
	succ : Untypable
	eval#0 : Untypable
Inconclusive
[]

            (x => x + 1)(x => x + 1); // free conclusion type from NumOp2
        
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    WT: 'Num',
    YD: 'To(Ok, Ok)',
    ZH: 'Ok',
    XC: 'To(To(Ok, Ok), Comp(Ok))',
    WR: 'Num',
    XL: 'To(Ok, Ok)',
    ZS: 'Num',
    ZQ: 'Num',
    XF: 'To(Ok, Ok)',
    WK: 'Num',
    XE: 'Comp(Ok)',
    ZJ: 'Num',
    XN: 'Ok',
    WI: 'Ok',
    YM: 'Ok',
    WV: 'Comp(Ok)',
    ZU: 'Comp(Ok)',
    XB: 'Comp(Ok)'
  }
]

            const ifZ2 = 0 <= 0 ? (x => x + 1)(x => x + 1) : (x => x + 1)(x => x + 1); 
        
Solution
	ifZ2 : Comp(Ok)
Ill-typed and fails at: ifZ2
[
  {
    ZAO: 'Num',
    WAV: 'Num',
    XAL: 'Num',
    ZAQ: 'Num',
    XO: 'To(Comp(Ok), To(Num, Num))',
    ZT: 'Num',
    XH: 'Comp(Ok)',
    XAA: 'To(To(Num, Num), Comp(Ok))',
    YAK: 'Num',
    XAD: 'To(Num, Num)',
    ZK: 'Comp(Ok)',
    XAN: 'Num',
    XF: 'To(To(Comp(Ok), To(Num, Num)), Comp(Ok))',
    XI: 'To(Comp(Ok), To(Num, Num))',
    ZAF: 'Num',
    XAC: 'Comp(Ok)',
    XJ: 'To(To(Comp(Ok), To(Num, Num)), To(Comp(Ok), To(Num, Num)))',
    WAP: 'Num',
    XAM: 'Num',
    XAJ: 'To(Num, Num)',
    ZV: 'Num',
    XS: 'Comp(To(Comp(Ok), To(Num, Num)))',
    WAG: 'Num',
    WAR: 'Num',
    ZM: 'Num',
    XQ: 'To(Num, Num)',
    WW: 'Num',
    WL: 'To(Num, Num)',
    YG: 'To(Comp(Ok), To(Num, Num))',
    YP: 'Comp(Ok)',
    WN: 'Num',
    ZAH: 'Num',
    WAI: 'Num',
    WU: 'Num',
    ZAU: 'Num',
    YAB: 'To(Num, Num)',
    WY: 'Comp(Ok)',
    WAT: 'Comp(Ok)',
    ZAS: 'Comp(Ok)',
    XZ: 'Comp(Ok)',
    ZX: 'Comp(Ok)',
    XE: 'Comp(Ok)',
    TB: 'Comp(Ok)',
    XC: 'Comp(Ok)'
  }
]

            const okC1 = (x => x)(0(0)); //variable x goes wrong (Y1 = Comp(Ok))
        
Solution
	okC1 : Comp(Ok)
Ill-typed and fails at: okC1
[
  {
    ZJ: 'Comp(Ok)',
    YE: 'Ok',
    XH: 'Num',
    XG: 'Comp(Ok)',
    XF: 'Num',
    WK: 'Comp(Ok)',
    XI: 'To(Num, Num)',
    ZL: 'Comp(Ok)',
    WM: 'Comp(Ok)',
    TB: 'Comp(Ok)',
    XC: 'Comp(Ok)'
  }
]
f => x => f(f(x));
	eval#0 : Untypable
Inconclusive
[]
(f => g => f + g);
	eval#0 : Untypable
Inconclusive
[]
(f => g => f + g)(0);
	eval#0 : Untypable
Inconclusive
[]
(f => g => f + g)(0)(0);
	eval#0 : Untypable
Inconclusive
[]
(f => g => f + g(0))(0)(x => x);
	eval#0 : Untypable
Inconclusive
[]
(x => x)(0) + 0;
	eval#0 : Untypable
Inconclusive
[]
(x => x);
	eval#0 : Untypable
Inconclusive
[]
(x => x)(0);
	eval#0 : Untypable
Inconclusive
[]
(x => x)(x => x);
	eval#0 : Untypable
Inconclusive
[]
0 + 0;
	eval#0 : Untypable
Inconclusive
[]
1 <= 0 ? 0(0) : 0;
	eval#0 : Untypable
Inconclusive
[]
(f => x => f(f(x)))(y => y + 1)((x => 0)(1));
	eval#0 : Untypable
Inconclusive
[]
(f => x => f(f(x)))(y => x => y)(0);
	eval#0 : Untypable
Inconclusive
[]
x => 0(x);
	eval#0 : Untypable
Inconclusive
[]
0(0);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    XD: 'To(Num, Num)',
    XC: 'Num',
    ZE: 'Comp(Ok)',
    WF: 'Comp(Ok)',
    XB: 'Comp(Ok)'
  }
]
(x => x) + 0;
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    ZI: 'Num',
    WJ: 'Num',
    YD: 'Num',
    XE: 'Num',
    WH: 'Num',
    XC: 'To(Num, Num)',
    ZG: 'Num',
    XB: 'Comp(Ok)'
  }
]
(x => x <= 0 ? 0 : 0)(y => y);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    YD: 'To(Num, Num)',
    XM: 'Num',
    XF: 'To(Num, Num)',
    YL: 'Num',
    ZI: 'Num',
    WJ: 'Num',
    XE: 'Comp(Ok)',
    XK: 'To(Num, Num)',
    XC: 'To(To(Num, Num), Comp(Ok))',
    XH: 'Num',
    XG: 'Num',
    WO: 'Comp(Ok)',
    ZN: 'Comp(Ok)',
    XB: 'Comp(Ok)'
  }
]
(f => g => f + g)(0)(x => x);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    YS: 'Comp(Ok)',
    ZM: 'Comp(Ok)',
    XO: 'Ok',
    WL: 'Num',
    XH: 'Comp(Ok)',
    XT: 'Num',
    YG: 'To(Comp(Ok), Num)',
    XC: 'To(To(Comp(Ok), Num), Comp(Ok))',
    YE: 'Ok',
    XD: 'To(Ok, To(To(Comp(Ok), Num), Comp(Ok)))',
    ZK: 'Num',
    WN: 'Num',
    XF: 'To(To(Comp(Ok), Num), Comp(Ok))',
    XR: 'To(Comp(Ok), Num)',
    XJ: 'To(Comp(Ok), Num)',
    WQ: 'To(Num, To(To(Comp(Ok), Num), Comp(Ok)))',
    ZP: 'To(Num, Comp(Ok))',
    WV: 'Comp(Ok)',
    ZU: 'Comp(Ok)',
    XB: 'Comp(Ok)'
  }
]
0 - (x => x <= 0 ? 1 : 0);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    YE: 'Comp(Ok)',
    XD: 'To(Comp(Ok), Num)',
    ZL: 'Num',
    XF: 'Num',
    WK: 'Num',
    WM: 'Num',
    ZJ: 'Num',
    ZN: 'Comp(Ok)',
    WO: 'Num',
    XI: 'Num',
    XH: 'Num',
    XB: 'Comp(Ok)'
  }
]
(x => x) - (y => y);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    YD: 'Ok',
    ZK: 'Num',
    XF: 'To(Num, Num)',
    ZI: 'Num',
    WJ: 'Num',
    XE: 'To(Num, Num)',
    WL: 'Num',
    XH: 'Num',
    YG: 'Num',
    XB: 'Comp(Ok)'
  }
]
(f => x => 0 - f(x)(0)) <= 0 ? 0 : 0;
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    YD: 'Num',
    WQ: 'To(Num, Num)',
    ZX: 'Num',
    XO: 'To(Num, Num)',
    XK: 'Num',
    ZT: 'Num',
    XC: 'To(Num, To(Comp(Ok), To(Num, Num)))',
    XL: 'Comp(Ok)',
    YF: 'Comp(Ok)',
    WS: 'Num',
    XI: 'To(Num, Num)',
    ZR: 'Num',
    WY: 'To(Comp(Ok), To(Num, Num))',
    XE: 'To(Comp(Ok), To(Num, Num))',
    WU: 'Num',
    XJ: 'Num',
    XG: 'To(Num, Num)',
    ZP: 'To(Num, Comp(Ok))',
    WN: 'To(Num, Num)',
    ZM: 'To(Num, Comp(Ok))',
    XB: 'Comp(Ok)'
  }
]
(y => x => y(1) + y(x))(x => x + 1)((z => z <= 0 ? (x => x) : (y => y))(0));
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    XAL: 'Comp(Num)',
    XAU: 'Num',
    WAC: 'Num',
    WV: 'Num',
    XO: 'To(To(Comp(Ok), Num), To(Num, Num))',
    XK: 'To(Num, Num)',
    XP: 'To(Comp(Ok), Num)',
    XAO: 'Num',
    XH: 'Comp(Ok)',
    XAI: 'To(Num, To(Comp(Ok), Num))',
    XAR: 'Num',
    XY: 'To(Num, Num)',
    XF: 'To(To(Comp(Ok), Num), Comp(Ok))',
    YAJ: 'Num',
    XI: 'To(Ok, Num)',
    XW: 'To(To(Comp(Ok), Num), To(Num, Num))',
    WAE: 'Num',
    ZU: 'Num',
    XJ: 'To(To(Comp(Ok), Num), To(Num, Num))',
    XAM: 'To(Comp(Ok), Num)',
    WT: 'Num',
    ZAD: 'Num',
    XAH: 'To(Comp(Ok), Num)',
    XAK: 'To(Comp(Ok), Num)',
    WAT: 'Num',
    XC: 'To(To(Comp(Ok), Num), Comp(Ok))',
    YG: 'To(Comp(Ok), Num)',
    ZAB: 'Comp(Ok)',
    YE: 'To(To(Comp(Ok), Num), To(Num, Num))',
    XD: 'To(To(To(Comp(Ok), Num), To(Num, Num)), To(To(Comp(Ok), Num), Comp(Ok)))',
    ZS: 'Num',
    YAN: 'Comp(Ok)',
    YAQ: 'Comp(Ok)',
    XZ: 'To(Comp(Ok), Num)',
    XN: 'To(Num, Num)',
    XAP: 'To(Comp(Ok), Num)',
    YX: 'To(Comp(Ok), Num)',
    ZAS: 'Num',
    WAG: 'To(Num, To(To(Comp(Ok), Num), Comp(Ok)))',
    ZAF: 'To(Num, Comp(Ok))',
    ZQ: 'To(Num, Comp(Ok))',
    ZL: 'To(Num, Comp(Ok))',
    ZAV: 'To(Num, Comp(Ok))',
    WAY: 'Comp(Ok)',
    ZAX: 'Comp(Ok)',
    XB: 'Comp(Ok)'
  }
]
(x => x(0))(0);
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    ZH: 'Comp(Ok)',
    YD: 'Num',
    XF: 'Num',
    WI: 'Comp(Ok)',
    XE: 'Comp(Ok)',
    XC: 'To(Num, Comp(Ok))',
    XJ: 'Num',
    XG: 'To(Num, Num)',
    WL: 'Comp(Ok)',
    ZK: 'Comp(Ok)',
    XB: 'Comp(Ok)'
  }
]
thing => thing
	eval#0 : Untypable
Inconclusive
[]
(cannotBeNum => cannotBeNum(0))(0)
Solution
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    ZH: 'Comp(Ok)',
    YD: 'Num',
    XF: 'Num',
    WI: 'Comp(Ok)',
    XE: 'Comp(Ok)',
    XC: 'To(Num, Comp(Ok))',
    XJ: 'Num',
    XG: 'To(Num, Num)',
    WL: 'Comp(Ok)',
    ZK: 'Comp(Ok)',
    XB: 'Comp(Ok)'
  }
]

            const x = 0;
        
	x : Untypable
Inconclusive
[]

            const x = y => y;
            const z = w => {
                return x(w);
            }
        
	x : Untypable
	z : Untypable
Inconclusive
[]

            const x = 0;
        
	x : Untypable
Inconclusive
[]

            x => x
        
	eval#0 : Untypable
Inconclusive
[]

            const x = y => y;
        
	x : Untypable
Inconclusive
[]

            const mul = x => y => {
                return x <= 0 ? y : y + mul(x - 1)(y);
            }
        
	mul : Untypable
Inconclusive
[]

            const mul = x => y => {
                return x <= 0 ? y : y + mul(x - 1)(y);
            }
            const result = mul(2)(3);
        
	mul : Untypable
	result : Untypable
Inconclusive
[]

            const pair = m => n => p => p(m)(n);
            const div = n => d => q => {
                const r = n - d; 
                return r + 1 <= 0 ? pair(q)(n) : div(r)(d)(q + 1);
            }
            const goodResult = div(10)(2)(0);
        
	pair : Untypable
	div : Untypable
	goodResult : Untypable
Inconclusive
[]

            const fst = x => y => x;
            const snd = x => y => y;
            const pair = m => n => p => p(m)(n);
            const listZeros = pair(0)(pair(0)(pair(0)(pair(0)(0))));
            const head = fst;
            listZeros(head);
        
	fst : Untypable
	snd : Untypable
	pair : Untypable
	listZeros : Untypable
	head : Untypable
	eval#0 : Untypable
Inconclusive
[]

            const boomPair = m => n => p => 1(x => x) - 1(0)(0)(m)(n);
            const listZeros = boomPair(0)(boomPair(0)(boomPair(0)(boomPair(0)(0))));
        
	boomPair : Untypable
	listZeros : Untypable
Inconclusive
[]

            const pfst = s => t => s;
            const psnd = s => t => t;
            const qfst = q => r => s => t => q;
            const qsnd = q => r => s => t => r;
            const qtrd = q => r => s => t => s;
            const qfrt = q => r => s => t => t;
            const quad = q => r => s => t => p => p(q)(r)(s)(t);
            const pair = r => s => p => p(r)(s);
            const toTwoPairs = inQuad => {
                const p1 = pair(inQuad(qfst))(inQuad(qsnd));
                const p2 = pair(inQuad(qtrd))(inQuad(qfrt));
                return pair(p1)(p2);
            }
            const myQuad = quad(0)(1)(2)(3);
            const firstPair = toTwoPairs(myQuad)(pfst);
            const sndPair = toTwoPairs(myQuad)(psnd);
        
	pfst : Untypable
	psnd : Untypable
	qfst : Untypable
	qsnd : Untypable
	qtrd : Untypable
	qfrt : Untypable
	quad : Untypable
	pair : Untypable
	toTwoPairs : Untypable
	myQuad : Untypable
	firstPair : Untypable
	sndPair : Untypable
Inconclusive
[]

            const id = x => x;
            const explode = x => id - 1;
            const zero = id(0);
        
	id : Untypable
	explode : Untypable
	zero : Untypable
Inconclusive
[]

            const earlyFail = (x => 0)(0)(0);
            const two = 1 + 1;
            two + 1;
        
Solution
	earlyFail : Comp(Ok)
	two : Ok
	eval#0 : Ok
Ill-typed and fails at: earlyFail
[
  {
    XG: 'Num',
    WAB: 'Num',
    WZ: 'Num',
    XQ: 'To(To(To(To(To(To(Comp(Ok), Num), To(Comp(Ok), Num)),To(To(Comp(Ok), Num), To(Comp(Ok), Num))), To(Comp(Ok), Num)),To(To(To(To(Comp(Ok), Num), To(Comp(Ok), Num)),To(To(Comp(Ok), Num), To(Comp(Ok), Num))), To(Comp(Ok), Num))), To(Comp(Ok), Num))',
    XK: 'To(Num, Num)',
    XP: 'To(To(To(To(Comp(Ok), Num), To(Comp(Ok), Num)),To(To(Comp(Ok), Num), To(Comp(Ok), Num))), To(Comp(Ok), Num))',
    ZT: 'Num',
    XX: 'To(To(Comp(Ok), Num), To(Comp(Ok), Num))',
    XV: 'Ok',
    XH: 'Ok',
    ZY: 'Num',
    XD: 'Num',
    YF: 'Ok',
    TN: 'Ok',
    WS: 'Num',
    ZR: 'Num',
    XE: 'To(Ok, Num)',
    WU: 'Num',
    ZAA: 'Num',
    TB: 'Comp(Ok)',
    WJ: 'To(Num, Num)',
    ZI: 'To(Num, Comp(Ok))',
    ZL: 'Comp(Ok)',
    WM: 'Comp(Ok)',
    XC: 'Comp(Ok)',
    XO: 'Ok'
  }
]

            const zeroer = x => y => {
                return 0(x) <= 0 ? 0 : 0;
            }
            zeroer(0)(0);
        
Solution
	zeroer : (Num -> (Ok -> Comp(Ok)))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    ZN: 'Comp(Ok)',
    XQ: 'Comp(Ok)',
    XK: 'To(Num, Num)',
    WO: 'To(Num, Num)',
    XH: 'Comp(Ok)',
    XV: 'To(Num, To(Ok, Comp(Ok)))',
    YG: 'Ok',
    YE: 'Num',
    XL: 'Num',
    XM: 'To(Num, Num)',
    XF: 'To(Ok, Comp(Ok))',
    WS: 'Num',
    XW: 'Num',
    XU: 'To(Ok, Comp(Ok))',
    ZR: 'Num',
    XZ: 'Ok',
    WY: 'To(Num, To(Ok, Comp(Ok)))',
    ZX: 'To(Num, Comp(Ok))',
    XI: 'Comp(Ok)',
    ZAA: 'Comp(Ok)',
    XJ: 'Comp(Ok)',
    XP: 'Comp(Ok)',
    WAB: 'Comp(Ok)',
    TB: 'Num',
    TC: 'To(Ok, Comp(Ok))',
    XT: 'Comp(Ok)',
    XD: 'To(Num, To(Ok, Comp(Ok)))'
  }
]

            const mul = 0(0);
        
Solution
	mul : Comp(Ok)
Ill-typed and fails at: mul
[
  {
    XD: 'Num',
    XE: 'To(Num, Num)',
    ZF: 'Comp(Ok)',
    WG: 'Comp(Ok)',
    TB: 'Comp(Ok)',
    XC: 'Comp(Ok)'
  }
]

            const pair = m => n => p => p(m)(n);
            const div = n => d => q => {
                const r = n - d; 
                return r + 1 <= 0 ? pair(q)(n) : div(r)(d)(q + 1);
            }
            
            const badResult = div(x => x)(10)(0);
        
Solution
	pair : (Num -> (Ok -> ((Num -> Num) -> Num)))
	div : ((Num -> Num) -> (Ok -> (Ok -> Comp(Ok))))
	badResult : Comp(Ok)
Ill-typed and fails at: badResult
[
  {
    WAU: 'Num',
    ZBT: 'Num',
    ZAK: 'Num',
    YCH: 'Num',
    XH: 'To(To(Num, Num), Num)',
    XAI: 'To(Num, Num)',
    XCO: 'Ok',
    XAX: 'Comp(Ok)',
    XY: 'To(Ok, Comp(Ok))',
    XW: 'To(Ok, To(Ok, Comp(Ok)))',
    WAN: 'Num',
    XBK: 'Comp(Ok)',
    WCA: 'Num',
    ZBV: 'Num',
    ZAT: 'Num',
    XBN: 'Num',
    YI: 'To(Num, Num)',
    XCL: 'Ok',
    YV: 'To(Num, Num)',
    ZAM: 'Num',
    YE: 'Num',
    XCI: 'Num',
    XBD: 'Num',
    XAP: 'Comp(Ok)',
    XCF: 'To(To(Num, Num), To(Ok, To(Ok, Comp(Ok))))',
    XCG: 'To(Num, Num)',
    WAL: 'Num',
    WAW: 'Num',
    WBW: 'Num',
    XBA: 'Num',
    XK: 'Num',
    XP: 'To(Num, Num)',
    YAC: 'Comp(Ok)',
    XAA: 'Comp(Ok)',
    ZAV: 'Num',
    XBQ: 'To(Num, Num)',
    YZ: 'Ok',
    XM: 'Num',
    XCD: 'To(Ok, Comp(Ok))',
    XF: 'To(Ok, To(To(Num, Num), Num))',
    XCE: 'To(Ok, To(Ok, Comp(Ok)))',
    XJ: 'Num',
    XAJ: 'To(Num, Num)',
    XBI: 'Num',
    XBH: 'Num',
    YG: 'Ok',
    WBU: 'Num',
    XL: 'To(Num, Num)',
    ZBZ: 'Num',
    XAY: 'Num',
    YX: 'Ok',
    XBG: 'Comp(Ok)',
    WBY: 'To(Num, Comp(Ok))',
    ZBX: 'To(Num, Comp(Ok))',
    WBP: 'To(Num, Num)',
    ZBO: 'To(Num, Comp(Ok))',
    WBM: 'To(Num, Num)',
    ZBL: 'To(Num, Comp(Ok))',
    WBF: 'To(Num, Comp(Ok))',
    ZBE: 'To(Num, Comp(Ok))',
    WBC: 'To(Num, Num)',
    ZBB: 'To(Num, Comp(Ok))',
    WO: 'To(Num, Num)',
    ZN: 'To(Num, Comp(Ok))',
    WCN: 'To(Num, To(Ok, Comp(Ok)))',
    ZCM: 'To(Num, Comp(Ok))',
    WCK: 'To(Num, To(Ok, To(Ok, Comp(Ok))))',
    ZCJ: 'To(Num, Comp(Ok))',
    WCQ: 'Comp(Ok)',
    XAB: 'Comp(Ok)',
    ZQ: 'Comp(Ok)',
    ZCP: 'Comp(Ok)',
    XAO: 'Comp(Ok)',
    XAH: 'Comp(Ok)',
    WR: 'Num',
    TB: 'Num',
    TS: 'To(Num, Num)',
    TC: 'To(Ok, To(To(Num, Num), Num))',
    TT: 'To(Ok, To(Ok, Comp(Ok)))',
    XCC: 'Comp(Ok)',
    TCB: 'Comp(Ok)',
    XD: 'To(Num, To(Ok, To(To(Num, Num), Num)))',
    XU: 'To(To(Num, Num), To(Ok, To(Ok, Comp(Ok))))'
  }
]

            const fst = x => y => x;
            const pair = m => n => p => 10(m)(n); 
            const listZeros = pair(0)(pair(0)(pair(0)(pair(0)(0))));
            listZeros(fst);
        
Solution
	fst : (Ok -> Ok)
	pair : (Ok -> (Ok -> (Ok -> Comp(Ok))))
	listZeros : (Ok -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    XAS: 'Num',
    WBE: 'Comp(Ok)',
    XO: 'To(Ok, Comp(Ok))',
    XH: 'Num',
    XAD: 'Ok',
    XM: 'To(Ok, To(Ok, Comp(Ok)))',
    XF: 'Ok',
    YL: 'Ok',
    XW: 'Ok',
    XAN: 'To(Num, Comp(Ok))',
    XAV: 'To(Num, Num)',
    XR: 'To(Ok, Comp(Ok))',
    XAB: 'To(Ok, To(Ok, Comp(Ok)))',
    XAC: 'To(Ok, To(Ok, To(Ok, Comp(Ok))))',
    YN: 'Ok',
    WBA: 'Comp(Ok)',
    XAM: 'Ok',
    XS: 'Num',
    XAH: 'To(Num, Num)',
    XBI: 'To(Ok, Comp(Ok))',
    XBJ: 'Ok',
    XQ: 'Comp(Ok)',
    XAJ: 'To(Num, Num)',
    XBH: 'Comp(Ok)',
    XT: 'Num',
    TZ: 'To(Ok, Comp(Ok))',
    YG: 'Num',
    ZU: 'Comp(Ok)',
    YE: 'Ok',
    YP: 'Ok',
    WV: 'To(Ok, Comp(Ok))',
    XAP: 'To(Num, Num)',
    XAY: 'To(Num, Num)',
    XAT: 'Comp(To(Comp(Ok), Num))',
    XAG: 'Ok',
    WAF: 'To(Num, To(Ok, To(Ok, Comp(Ok))))',
    ZAE: 'To(Num, Comp(Ok))',
    ZBD: 'To(Num, Comp(Ok))',
    WAL: 'To(Num, To(Num, Num))',
    ZAK: 'To(Num, Comp(Ok))',
    ZBB: 'To(Num, Comp(Ok))',
    WAR: 'To(Num, To(Num, Comp(Ok)))',
    ZAQ: 'To(Num, Comp(Ok))',
    ZAZ: 'To(Num, Comp(Ok))',
    WAX: 'To(Num, Comp(To(Comp(Ok), Num)))',
    ZAW: 'To(Num, Comp(Ok))',
    WY: 'Comp(Ok)',
    ZBF: 'Comp(Ok)',
    ZX: 'Comp(Ok)',
    ZBK: 'Comp(Ok)',
    WBL: 'Comp(Ok)',
    WBG: 'To(Ok, Comp(Ok))',
    TI: 'Ok',
    TB: 'Ok',
    TJ: 'To(Ok, To(Ok, Comp(Ok)))',
    TC: 'Ok',
    XAA: 'To(Ok, Comp(Ok))',
    XK: 'To(Ok, To(Ok, To(Ok, Comp(Ok))))',
    XD: 'To(Ok, Ok)'
  }
]

            const snd = x => y => y;
            const pair = m => n => p => p(m)(n);
            const confusedList = pair(0)(0)(0);
        
Solution
	snd : (Comp(Ok) -> Num)
	pair : (Ok -> (Num -> (Num -> Comp(Ok))))
	confusedList : Comp(Ok)
Ill-typed and fails at: confusedList
[
  {
    YN: 'Num',
    XAH: 'Num',
    XS: 'Num',
    XQ: 'Comp(Ok)',
    XO: 'To(Num, Comp(Ok))',
    XAK: 'Num',
    XT: 'Comp(Ok)',
    XAD: 'To(Ok, To(Num, To(Num, Comp(Ok))))',
    YP: 'Num',
    XM: 'To(Num, To(Num, Comp(Ok)))',
    YL: 'Ok',
    ZU: 'Comp(Ok)',
    XAB: 'To(Num, Comp(Ok))',
    XW: 'To(Num, Num)',
    XR: 'Num',
    XAE: 'Ok',
    WV: 'Num',
    XAC: 'To(Num, To(Num, Comp(Ok)))',
    WAJ: 'To(Num, To(Num, Comp(Ok)))',
    ZAI: 'To(Num, Comp(Ok))',
    WAG: 'To(Num, To(Num, To(Num, Comp(Ok))))',
    ZAF: 'To(Num, Comp(Ok))',
    WAM: 'Comp(Ok)',
    ZAL: 'Comp(Ok)',
    ZX: 'Comp(Ok)',
    YE: 'Comp(Ok)',
    WY: 'Comp(Ok)',
    TI: 'Ok',
    TB: 'Comp(Ok)',
    TJ: 'To(Num, To(Num, Comp(Ok)))',
    XF: 'Num',
    TC: 'Num',
    TZ: 'Comp(Ok)',
    XAA: 'Comp(Ok)',
    XK: 'To(Ok, To(Num, To(Num, Comp(Ok))))',
    XD: 'To(Comp(Ok), Num)'
  }
]

            const fst = s => t => s;
            const snd = s => t => t;
            const pair = s => t => p => p(s)(t);
            const p1 = pair(0)(1);
            const p2 = pair(2)(3);
            const zipSumPairs = pair1 => pair2 => {
                const e1 = pair1(fst) + pair2(fst);
                const e2 = pair1(snd) + snd(pair2); 
                return pair(e1)(e2);
            }
            const sumPair = zipSumPairs(p1)(p2);
        
Solution
	fst : (Num -> (Num -> Num))
	snd : (Ok -> (Num -> Ok))
	pair : (Num -> Ok)
	p1 : Ok
	p2 : Ok
	zipSumPairs : (Ok -> (Ok -> Comp(Ok)))
	sumPair : Comp(Ok)
Ill-typed and fails at: sumPair
[
  {
    XAS: 'Comp(To(Comp(Ok), Ok))',
    YBI: 'Ok',
    TEI: 'Comp(Ok)',
    XH: 'Num',
    XAI: 'To(Num, Num)',
    XBE: 'To(Ok, Comp(Ok))',
    XDL: 'To(Ok, To(Num, Num))',
    XAX: 'To(Num, Num)',
    XDP: 'To(Num, Ok)',
    XY: 'Num',
    YL: 'Ok',
    XCS: 'Num',
    XCN: 'Ok',
    ZCV: 'Num',
    XEM: 'Ok',
    XEP: 'Ok',
    XEA: 'Ok',
    XCQ: 'To(Ok, Num)',
    XDK: 'To(Num, Num)',
    YU: 'Ok',
    XCL: 'To(Ok, Num)',
    YDA: 'Comp(Ok)',
    ZDW: 'Num',
    WCW: 'Num',
    YE: 'Num',
    WDX: 'Ok',
    TAG: 'Ok',
    TAQ: 'Ok',
    XCM: 'To(Ok, To(Ok, Num))',
    YBF: 'Ok',
    YS: 'Num',
    XEK: 'To(Ok, Comp(Ok))',
    XAU: 'To(Num, Num)',
    XDZ: 'Comp(Ok)',
    XEB: 'To(Num, Ok)',
    XO: 'Ok',
    XAA: 'Ok',
    XV: 'Num',
    XEF: 'Num',
    XAD: 'To(Num, Num)',
    XM: 'To(Num, Ok)',
    XF: 'To(Num, Num)',
    XAN: 'To(Num, Num)',
    XDR: 'Ok',
    XEC: 'Ok',
    YN: 'Num',
    WDV: 'Num',
    XDM: 'Ok',
    XAK: 'To(Num, Num)',
    XT: 'Ok',
    XX: 'Num',
    WCY: 'Num',
    YG: 'Num',
    ZDU: 'Num',
    XEL: 'To(Ok, To(Ok, Comp(Ok)))',
    YBD: 'Ok',
    XZ: 'To(Ok, Num)',
    XDQ: 'To(Ok, To(Num, Ok))',
    XBG: 'Comp(Ok)',
    ZCX: 'Num',
    YW: 'To(Ok, Num)',
    WEH: 'To(Num, Comp(Ok))',
    ZEG: 'To(Num, Comp(Ok))',
    WEE: 'To(Num, Ok)',
    ZED: 'To(Num, Comp(Ok))',
    ZDS: 'To(Num, Comp(Ok))',
    ZDN: 'To(Num, Comp(Ok))',
    ZCT: 'To(Num, Comp(Ok))',
    ZCO: 'To(Num, Comp(Ok))',
    WAW: 'To(Num, Comp(To(Comp(Ok), Ok)))',
    ZAV: 'To(Num, Comp(Ok))',
    WAM: 'To(Num, To(Num, Num))',
    ZAL: 'To(Num, Comp(Ok))',
    WAC: 'To(Num, Num)',
    ZAB: 'To(Num, Comp(Ok))',
    WEO: 'To(Num, To(Ok, Comp(Ok)))',
    ZEN: 'To(Num, Comp(Ok))',
    WAP: 'Ok',
    XDY: 'Comp(Ok)',
    XBH: 'Comp(Ok)',
    WAF: 'Num',
    WER: 'Comp(Ok)',
    ZEQ: 'Comp(Ok)',
    WAZ: 'Ok',
    ZAY: 'Comp(Ok)',
    XDJ: 'Comp(Ok)',
    ZAE: 'Comp(Ok)',
    ZAO: 'Comp(Ok)',
    XCZ: 'Comp(Ok)',
    XCK: 'Ok',
    TB: 'Num',
    TJ: 'To(Num, Ok)',
    TBB: 'To(Ok, Comp(Ok))',
    TI: 'Ok',
    TQ: 'Ok',
    TP: 'Num',
    TC: 'To(Num, Num)',
    TBA: 'Ok',
    XAR: 'Ok',
    XAH: 'Ok',
    XR: 'To(Num, Ok)',
    XK: 'To(Ok, To(Num, Ok))',
    XD: 'To(Num, To(Num, Num))',
    XEJ: 'Comp(Ok)',
    XBC: 'To(Ok, To(Ok, Comp(Ok)))'
  }
]

            const fst = s => t => s;
            const snd = s => t => t;
            const sndFst = snd(fst);
            const idPlus1 = sndFst + 1;
        
Solution
	fst : (Num -> (Num -> Num))
	snd : (Ok -> (Num -> Num))
	sndFst : (Num -> Num)
	idPlus1 : Comp(Ok)
Ill-typed and fails at: idPlus1
[
  {
    YN: 'Num',
    ZZ: 'Num',
    XS: 'Ok',
    WAC: 'Num',
    XO: 'Num',
    XX: 'To(Num, Num)',
    XH: 'Num',
    YG: 'Num',
    ZAB: 'Num',
    YE: 'Num',
    TP: 'To(Num, Num)',
    XY: 'To(To(Comp(Ok), To(Num, Num)), To(Comp(Ok), To(Num, Num)))',
    XF: 'To(Num, Num)',
    YL: 'Ok',
    XM: 'To(Num, Num)',
    TV: 'Comp(Ok)',
    XR: 'To(Ok, To(Num, Num))',
    WAA: 'Num',
    WU: 'To(Num, Num)',
    ZT: 'Comp(Ok)',
    TI: 'Ok',
    TB: 'Num',
    TJ: 'To(Num, Num)',
    TC: 'To(Num, Num)',
    XW: 'Comp(Ok)',
    XK: 'To(Ok, To(Num, Num))',
    XD: 'To(Num, To(Num, Num))',
    XQ: 'To(Num, Num)'
  }
]

            const boomRecursion = x => {
                return x <= 0 ? 0(boomRecursion(x - 1)) : 0(x);
            }
            boomRecursion(10);
        
Solution
	boomRecursion : (Num -> Comp(Ok))
	eval#0 : Comp(Ok)
Ill-typed and fails at: eval#0
[
  {
    ZAD: 'Num',
    XAH: 'Num',
    WT: 'Num',
    XO: 'Num',
    XK: 'Num',
    ZAB: 'Comp(Ok)',
    XP: 'Num',
    XAA: 'To(Num, Num)',
    WR: 'Num',
    ZW: 'Comp(Ok)',
    YE: 'Num',
    XL: 'Num',
    ZS: 'Num',
    WAC: 'Comp(Ok)',
    XF: 'Comp(Ok)',
    XY: 'Comp(Ok)',
    ZQ: 'Num',
    WX: 'Comp(Ok)',
    WAE: 'Num',
    XN: 'Num',
    XZ: 'Num',
    XAG: 'To(Num, Comp(Ok))',
    ZU: 'To(Num, Comp(Ok))',
    XG: 'Comp(Ok)',
    WAJ: 'Comp(Ok)',
    XH: 'Comp(Ok)',
    ZAI: 'Comp(Ok)',
    XJ: 'Comp(Ok)',
    TB: 'Num',
    TC: 'Comp(Ok)',
    XAF: 'Comp(Ok)',
    XD: 'To(Num, Comp(Ok))'
  }
]

            const id = x => x;
            const funcGoesWrongWhenRun = y => id + id;
            const three = 2 + 1;
        
	id : Untypable
	funcGoesWrongWhenRun : Untypable
	three : Untypable
Inconclusive
[]

            const tenOrId = lTOrGTZ => {
                return lTOrGTZ <= 0 ? x => x : 10;
            }
            const eleven = tenOrId(1) + 1;
        
	tenOrId : Untypable
	eleven : Untypable
Inconclusive
[]

            const id = x => x;
        
	id : Untypable
Inconclusive
[]
[32m successes (101/103):
 	testVariables: line 105
	testVariables: line 106
	testVariables: line 107
	testVariables: line 108
	testVariables: line 109
	testVariables: line 110
	testVariables: line 116
	testExcludeTopDefns: line 554
	testExcludeTopDefns: line 555
	testWhereFails: line 402
	testWhereFails: line 412
	testWhereFails: line 450
	testEarlyFailAt: line 559
	testEarlyFailAt: line 573
	testEarlyFailAt: line 578
	testEarlyFailAt: line 584
	testEarlyFailAt: line 593
	testWhereFails: line 402
	testWhereFails: line 412
	testWhereFails: line 450
	testBlockIgnoresStillIllTyped: line 539
	testTypabilityByRule: line 467
	testTypabilityByRule: line 470
	testTypabilityByRule: line 474
	testTypabilityByRule: line 484
	testTypabilityByRule: line 493
	testTypabilityByRule: line 497
	testTypabilityByRule: line 500
	testTypeEquality: line 131
	testTypeEquality: line 132
	testTypeEquality: line 133
	testTypeEquality: line 134
	testTypeEquality: line 135
	testTypeEquality: line 137
	testTypeEquality: line 140
	testTypeEquality: line 141
	testTypeEquality: line 142
	testTypeEquality: line 143
	testUntypability: line 147
	testUntypability: line 148
	testUntypability: line 149
	testUntypability: line 150
	testUntypability: line 151
	testUntypability: line 152
	testUntypability: line 153
	testUntypability: line 154
	testUntypability: line 155
	testUntypability: line 156
	testUntypability: line 157
	testUntypability: line 158
	testUntypability: line 159
	testUntypability: line 160
	testTypability: line 164
	testTypability: line 165
	testTypability: line 166
	testTypability: line 167
	testTypability: line 168
	testTypability: line 169
	testTypability: line 170
	testTypability: line 171
	testTypability: line 173
	testFreshTypes: line 185
	testCheckTypeShape: line 189
	testCheckTypeShape: line 190
	testLongIdentifiers: line 194
	testLongIdentifiers: line 195
	testValidityOfNewGrammar: line 199
	testValidityOfNewGrammar: line 200
	testValidityOfNewGrammar: line 204
	testValidityOfNewGrammar: line 209
	testValidityOfNewGrammar: line 215
	testReconstrNewGrammarSucceeds: line 224
	testReconstrNewGrammarSucceeds: line 225
	testReconstrNewGrammarSucceeds: line 229
	testReconstrNewGrammarSucceeds: line 240
	testUntypableNewGrammar: line 249
	testUntypableNewGrammar: line 252
	testUntypableNewGrammar: line 258
	testUntypableNewGrammar: line 261
	testUntypableNewGrammar: line 264
	testUntypableNewGrammar: line 267
	testUntypableNewGrammar: line 272
	testUntypableNewGrammar: line 278
	testUntypableNewGrammar: line 286
	testUntypableNewGrammar: line 295
	testUntypableNewGrammar: line 299
	testUntypableNewGrammar: line 317
	testTypeableNewGrammar: line 334
	testTypeableNewGrammar: line 340
	testTypeableNewGrammar: line 346
	testTypeableNewGrammar: line 350
	testTypeableNewGrammar: line 360
	testTypeableNewGrammar: line 366
	testTypeableNewGrammar: line 373
	testTypeableNewGrammar: line 387
	testTypeableNewGrammar: line 393
	falsePositivesWeCantShowWrong: line 603
	falsePositivesWeCantShowWrong: line 608
	showSimpleRights: line 618
	testProgramsRun: line 525
	testProgramsRun: line 534 [0m
[31m failures (2/103):
 	testWhereFails: line 427
	testWhereFails: line 427 [0m
