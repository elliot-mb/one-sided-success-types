{
    "Literal": {
        "n": {
            "n": ["value"]
        }
    },
    "BinaryExpression": {
        "M o N": {
            "M": ["left"],
            "N": ["right"]
        }
    },
    "ArrayExpression": {
        "[M, N]": {
            "M": ["elements", "0"],
            "N": ["elements", "1"]
        }
    },
    "ArrowFunctionExpression": {
        "x => M": {
            "x": ["params", "0"],
            "M": ["body"]
        }
    },
    "CallExpression": {
        "M(N)": {
            "M": ["callee"],
            "N": ["arguments", "0"]
        }
    },
    "ConditionalExpression": {
        "M <= 0 ? N : P":{
            "M": ["test", "left"],
            "N": ["consequent"],
            "P": ["alternate"]
        }
    },
    "Identifier": {
        "x": {
            "x": ["name"]
        }
    },
    "VariableDeclaration":{
        "const x = M; E": {
            "x": ["declarations", "0", "id"],
            "M": ["declarations", "0", "init"],
            "E": ["next"]
        },
        "const f = x => N; E": {
            "f": ["declarations", "0", "id"],
            "x => N": ["declarations", "0", "init"],
            "x": ["declarations", "0", "init", "params", "0"],
            "N": ["declarations", "0", "init", "body"],
            "M": ["declarations", "0", "init"],
            "E": ["next"]
        }
    },
    "BlockStatement": {
        "{E}":{
            "E": ["body"]
        }
    },
    "ReturnStatement": { 
        "return M;": {
            "M": ["argument"]
        }
    },
    "ExpressionStatement": {
        "M;": {
            "M": ["expression"]
        },
        "M; E":{
            "M": ["expression"],
            "E": ["next"]
        }
    }
}